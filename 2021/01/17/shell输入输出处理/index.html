<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>shell输入输出处理 - Yiming&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Yiming&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Yiming&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="shell 处理输入输出处理用户输入命令行参数 读取参数。  bash shell会将一些称为位置参数的特殊变量分配给输入到命令行中的所有参数。位置参数是标准的数字：$0是程序名，$1是第一个参数，一直到$9。如果参数不止9个，需要使用$&amp;amp;#123;10&amp;amp;#125;这种方式使用参数。"><meta property="og:type" content="blog"><meta property="og:title" content="shell输入输出处理"><meta property="og:url" content="https://afawa.github.io/2021/01/17/shell%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/"><meta property="og:site_name" content="Yiming&#039;s Blog"><meta property="og:description" content="shell 处理输入输出处理用户输入命令行参数 读取参数。  bash shell会将一些称为位置参数的特殊变量分配给输入到命令行中的所有参数。位置参数是标准的数字：$0是程序名，$1是第一个参数，一直到$9。如果参数不止9个，需要使用$&amp;amp;#123;10&amp;amp;#125;这种方式使用参数。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://afawa.github.io/img/og_image.png"><meta property="article:published_time" content="2021-01-17T09:26:42.000Z"><meta property="article:modified_time" content="2021-01-18T16:51:33.816Z"><meta property="article:author" content="Yiming He"><meta property="article:tag" content="shell programming"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://afawa.github.io/2021/01/17/shell%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/"},"headline":"Yiming's Blog","image":["https://afawa.github.io/img/og_image.png"],"datePublished":"2021-01-17T09:26:42.000Z","dateModified":"2021-01-18T16:51:33.816Z","author":{"@type":"Person","name":"Yiming He"},"description":"shell 处理输入输出处理用户输入命令行参数 读取参数。  bash shell会将一些称为位置参数的特殊变量分配给输入到命令行中的所有参数。位置参数是标准的数字：$0是程序名，$1是第一个参数，一直到$9。如果参数不止9个，需要使用$&amp;#123;10&amp;#125;这种方式使用参数。"}</script><link rel="canonical" href="https://afawa.github.io/2021/01/17/shell%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Yiming&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-01-17T09:26:42.000Z" title="2021-01-17T09:26:42.000Z">2021-01-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-01-18T16:51:33.816Z" title="2021-01-18T16:51:33.816Z">2021-01-19</time></span><span class="level-item"><a class="link-muted" href="/categories/programming-language/">programming language</a></span><span class="level-item">28 minutes read (About 4205 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">shell输入输出处理</h1><div class="content"><h2 id="shell-处理输入输出"><a href="#shell-处理输入输出" class="headerlink" title="shell 处理输入输出"></a>shell 处理输入输出</h2><h3 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h3><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><ol>
<li><p>读取参数。</p>
<ol>
<li><p>bash shell会将一些称为位置参数的特殊变量分配给输入到命令行中的所有参数。位置参数是标准的数字：<code>$0</code>是程序名，<code>$1</code>是第一个参数，一直到<code>$9</code>。如果参数不止9个，需要使用<code>$&#123;10&#125;</code>这种方式使用参数。</p>
<a id="more"></a>
</li>
<li><p>如果参数值中包含空格，需要使用引号来（单引号或者双引号），将文本字符串作为参数传递时，引号并非数据的一部分，只是表明数据的起止位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh <span class="string">&quot;Rich Blum&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>读取脚本名。可以使用$0获取shell在命令行启动的脚本名。但是这里存在一个问题，如果使用另一个命令来运行shell脚本，命令会和脚本名混在一起，出现在$0参数中。并且如果使用脚本完整路径使用脚本时，会显示脚本的绝对路径。为了只使用脚本的名称，可以使用<code>basename</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=$(basename <span class="variable">$0</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>测试参数。需要在使用之前检查是否传入了对应量的参数。下面是一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;not define&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h4 id="特殊参数变量"><a href="#特殊参数变量" class="headerlink" title="特殊参数变量"></a>特殊参数变量</h4></li>
<li><p>参数统计。<code>$#</code>变量中存储了脚本运行时携带的命令行参数的个数。如果想要之间使用最后一个参数，可以使用<code>$&#123;!#&#125;</code>来引用。</p>
</li>
<li><p>抓取所有数据。<code>$@</code>和<code>$*</code>可以用来对于参数进行遍历。</p>
<ol>
<li><code>$*</code>变量会将命令行上提供的所有参数保存为一个单词。</li>
<li><code>$@</code>变量会将命令行上提供的所有参数当作同一个字符串中的多个独立的单词。（用于遍历十分方便）</li>
</ol>
</li>
</ol>
<h4 id="移动变量"><a href="#移动变量" class="headerlink" title="移动变量"></a>移动变量</h4><ol>
<li><p><code> shift</code> 命令可以用来操作命令行参数，默认情况下它会将每个参数向左移动一个位置，<code>$3 -&gt; $2</code> 并且原来的<code>$1</code>直接消失，<code>$0</code>内依然是脚本名。当不知道有多少参数时，可以用它配合<code>while</code>进行遍历。例子如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$1</span></span><br><span class="line">	<span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>同时也可以对于<code>shift</code>指定一个数字，代表移动的数量，<code>shift 2</code>就是移动两个变量。</p>
</li>
</ol>
<h4 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h4><ol>
<li><p>查找选项</p>
<ol>
<li><p>处理简单选项。可以使用<code>case</code>语句配合<code>shift</code>进行选项提取。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span> </span><br><span class="line">		-a) <span class="built_in">echo</span> <span class="string">&quot;Found -a&quot;</span> ;;</span><br><span class="line">		-b) <span class="built_in">echo</span> <span class="string">&quot;Found -b&quot;</span> ;;</span><br><span class="line">		*) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not a option&quot;</span> ;;</span><br><span class="line">	<span class="keyword">esac</span></span><br><span class="line">	<span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>分离参数和选项。如果在脚本中同时使用选项和参数，Linux中处理这个问题的标准方式是用特殊字符将两者分开。对Linux来说，这个特殊字符是<code>--</code>。shell会用<code>--</code>来表明选项列表的结束，之后的都会被当作命令行参数。实现时只需要在case语句中加入对于<code>--</code>的判断。</p>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span> </span><br><span class="line">		-a) <span class="built_in">echo</span> <span class="string">&quot;Found -a&quot;</span> ;;</span><br><span class="line">  			-b) <span class="built_in">echo</span> <span class="string">&quot;Found -b&quot;</span> ;;</span><br><span class="line">  		--) <span class="built_in">shift</span></span><br><span class="line">  			<span class="built_in">break</span> ;;</span><br><span class="line">  		*) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not a option&quot;</span> ;;</span><br><span class="line">  	<span class="keyword">esac</span></span><br><span class="line">  	<span class="built_in">shift</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> para <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;Parameter <span class="variable">$para</span>&quot;</span></span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>处理带值的选项。例子如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">		-a) <span class="built_in">echo</span> <span class="string">&quot;Found -a&quot;</span> ;;</span><br><span class="line">		-b) para=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">			<span class="built_in">echo</span> <span class="string">&quot;Found -b, parameter=<span class="variable">$para</span>&quot;</span></span><br><span class="line">			<span class="built_in">shift</span> ;;</span><br><span class="line">		--) <span class="built_in">shift</span></span><br><span class="line">			<span class="built_in">break</span> ;;</span><br><span class="line">		*) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not a option&quot;</span> ;;</span><br><span class="line">	<span class="keyword">esac</span></span><br><span class="line">	<span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">for</span> para <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Parameter <span class="variable">$para</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这里<code>-b</code>选项需要一个额外的参数。</p>
</li>
</ol>
</li>
<li><p>使用<code>getopt</code>命令。上面的内容无法处理更加复杂的需求，例如我们想要把多个选项放到一个参数中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh -ac</span><br></pre></td></tr></table></figure>
<p>这样的操作需要使用<code>getopt</code>选项</p>
<ol>
<li><p><code>getopt</code>格式。<code>getopt optstring parameters</code>，其中<code>optstring</code>定义了有效的选项字母，还定义了哪些选项需要参数值。在<code>optstring</code>中列出每个需要参数值的字母，然后再每个需要参数值的选项字母后加一个冒号。<code>getopt</code>会根据<code>optstring</code>进行解析。例子如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ getopt ab:<span class="built_in">cd</span> -a -b test1 -<span class="built_in">cd</span> test2 test3</span><br><span class="line">-a -b test1 -c -d -- test2 test3</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>如果指定了一个不在<code>optstring</code>中的选项，默认情况下会产生一条错误信息，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ getopt ab:<span class="built_in">cd</span> -a -b test1 -cde test2 test3</span><br><span class="line">getopt: invalid option -- <span class="string">&#x27;e&#x27;</span></span><br><span class="line">-a -b test1 -c -d -- test2 test3</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>可以在命令后加入<code>-q</code>选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ getopt -q ab:<span class="built_in">cd</span> -a -b test1 -cde test2 test3</span><br><span class="line">-a -b test1 -c -d -- test2 test3</span><br><span class="line">$</span><br></pre></td></tr></table></figure></li>
<li><p>在脚本中使用<code>getopt</code>。方法是使用<code>getopt</code>命令生成的格式化后的版本来替换已有的命令行选项和参数。需要使用<code>set</code>命令。<code>set</code>命令的选项之一是<code>--</code>，它会将命令行参数替换为<code>set</code>命令的命令行值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -- $(getopt -q ab:<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">		-a) <span class="built_in">echo</span> <span class="string">&quot;Found -a&quot;</span> ;;</span><br><span class="line">		-b) para=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">			<span class="built_in">echo</span> <span class="string">&quot;Found -b, parameter=<span class="variable">$para</span>&quot;</span></span><br><span class="line">			<span class="built_in">shift</span> ;;</span><br><span class="line">		-c) <span class="built_in">echo</span> <span class="string">&quot;Found -c&quot;</span> ;;</span><br><span class="line">		-d) <span class="built_in">echo</span> <span class="string">&quot;Found -d&quot;</span> ;;</span><br><span class="line">		--) <span class="built_in">shift</span></span><br><span class="line">			<span class="built_in">break</span> ;;</span><br><span class="line">		*) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not a option&quot;</span> ;;</span><br><span class="line">	<span class="keyword">esac</span></span><br><span class="line">	<span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">for</span> para <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Parameter <span class="variable">$para</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>但是<code>getopt</code>任然存在一个小问题：<code>getopt</code>并不擅长处理带引号和空格的场景，对于上述代码，下面的方法可以解决这个问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh -a -b test1 -<span class="built_in">cd</span> <span class="string">&quot;test2 test3&quot;</span> test4</span><br><span class="line">Found -a</span><br><span class="line">Found -b, parameter=test1</span><br><span class="line">Found -c</span><br><span class="line">Found -d</span><br><span class="line">Parameter <span class="string">&#x27;test2</span></span><br><span class="line"><span class="string">Parameter test3&#x27;</span></span><br><span class="line">parameter <span class="string">&#x27;test4&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><code>getopts</code>命令。与<code>getopt</code>不同，前者将命令行上选项和参数处理后只生成一个输出，而<code>getopts</code>命令能够和已有的shell参数变量配合。每次调用它时，它一次处理命令行上检测的一个参数。处理完所有参数后，它会退出并返回一个大于0的退出码。可以和循环命令结合使用。命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getopts</span> optstring variable</span><br></pre></td></tr></table></figure>
<p>其中<code>optstring</code>和<code>getopt</code>命令类似，注意如果需要去掉错误信息的话，可以在<code>optstring</code>之前加一个冒号。<code>getopts</code>命令将当前参数保存在命令行中定义的variable中。<code>getopts</code>命令会用到两个环境变量，如果选项需要跟一个参数值，<code>OPTARG</code>环境变量就会保存这个值。<code>OPTIND</code>环境变量保存了参数列表中<code>getopts</code>正在处理的参数位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :ab:c opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$opt</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">   a) <span class="built_in">echo</span> <span class="string">&quot;Found -a&quot;</span> ;;</span><br><span class="line">   b) <span class="built_in">echo</span> <span class="string">&quot;Found -b, parameter <span class="variable">$OPTARG</span>&quot;</span> ;;</span><br><span class="line">   c) <span class="built_in">echo</span> <span class="string">&quot;Found -c&quot;</span> ;;</span><br><span class="line">   *) <span class="built_in">echo</span> <span class="string">&quot;Unknown option <span class="variable">$opt</span>&quot;</span> ;;</span><br><span class="line">   <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>注意对于<code>$OPTARG</code>如果包含空格需要用引号包裹。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh -ab <span class="string">&quot;test1 test2&quot;</span> -c</span><br><span class="line">Found -a</span><br><span class="line">Found -b, parameter test1 test2</span><br><span class="line">Found -c</span><br></pre></td></tr></table></figure>
<p>初次之外，<code>getopts</code>将命令行上找到的所有未定义的选项统一输出为问号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh -ab <span class="string">&quot;test1 test2&quot;</span> -c -d</span><br><span class="line">Found -a</span><br><span class="line">Found -b, parameter test1 test2</span><br><span class="line">Found -c</span><br><span class="line">Unknown option ?</span><br></pre></td></tr></table></figure>
<p><code>getopts</code>只会处理选项参数，可以使用<code>shift</code>结合<code>OPTIND</code>环境变量来解析后续参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :ab:c opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$opt</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">   a) <span class="built_in">echo</span> <span class="string">&quot;Found -a&quot;</span> ;;</span><br><span class="line">   b) <span class="built_in">echo</span> <span class="string">&quot;Found -b, parameter <span class="variable">$OPTARG</span>&quot;</span> ;;</span><br><span class="line">   c) <span class="built_in">echo</span> <span class="string">&quot;Found -c&quot;</span> ;;</span><br><span class="line">   *) <span class="built_in">echo</span> <span class="string">&quot;Unknown option <span class="variable">$opt</span>&quot;</span> ;;</span><br><span class="line">   <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shift</span> $[ <span class="variable">$OPTIND</span> - 1 ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> para <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Parameter <span class="variable">$para</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>这样就可以处理了，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh -ab <span class="string">&quot;test1 test2&quot;</span> -c test3 test4</span><br><span class="line">Found -a</span><br><span class="line">Found -b, parameter test1 test2</span><br><span class="line">Found -c</span><br><span class="line">Parameter test3</span><br><span class="line">Parameter test4</span><br><span class="line">$ ./test.sh -ab test1 test2 -c test3 test4</span><br><span class="line">Found -a</span><br><span class="line">Found -b, parameter test1</span><br><span class="line">Parameter test2</span><br><span class="line">Parameter -c</span><br><span class="line">Parameter test3</span><br><span class="line">Parameter test4</span><br></pre></td></tr></table></figure>
<p>不过需要注意<code>getopts</code>解析时需要把选项放在参数之前，这点和<code>getopt</code>不一样，对于<code>getopt</code>或默认把参数整理出来放在最后。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ getopt ab:c -ab test1 test2 -c test3 test4</span><br><span class="line">   -a -b test1 -c -- test2 test3 test4</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="读取用户输入"><a href="#读取用户输入" class="headerlink" title="读取用户输入"></a>读取用户输入</h4><ol>
<li><p>基本的读取。<code>read</code>命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后<code>read</code>命令会将数据存在一个变量里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I&#x27;m <span class="variable">$name</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>read</code>命令包含了<code>-p</code>选项能够在命令行指定提示符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Who are you?&quot;</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I&#x27;m <span class="variable">$name</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>read</code>可以指定多个变量，输入的每个数值都会分配给变量列表中的下一个变量，如果变量数量不够，剩下的数据就全部分配给最后一个变量。<code>read</code>也可以不指定变量，这样的话收到的任何数据都会在特殊环境变量<code>REPLY</code>中。</p>
</li>
<li><p>超时，限定数目。</p>
<ol>
<li><code>-t</code>选项指定了<code>read</code>命令等待输入的秒数，当计时器过期之后，<code>read</code>命令返回一个非零退出码。</li>
<li>也可以不对输入过程计时，而是让<code>read</code>命令来统计输入的字符数。使用<code>-n</code>选项加上一个数字代表接受多少个字符。</li>
</ol>
</li>
<li><p>隐藏输入。使用<code>-s</code>命令避免<code>read</code>命令中输入的数据出现在显示器上。</p>
</li>
<li><p>从文件中读取。每次使用<code>read</code>都会读取文件的一行，直到文件末尾，使用方式就是 <code>cat + 管道 + while + read</code> 。（<code>done + 重定向</code>也是可以的）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count=1</span><br><span class="line">cat test.txt | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$count</span>  <span class="variable">$line</span>&quot;</span></span><br><span class="line">	count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="呈现数据"><a href="#呈现数据" class="headerlink" title="呈现数据"></a>呈现数据</h3><h4 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h4><ol>
<li><p>标准文件描述符。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符。bash shell保留了前三个文件描述符。</p>
<ol>
<li>0    <code>STDIN</code>     标准输入。</li>
<li>1    <code>STDOUT</code>  标准输出。当命令生成错误信息时，shell创建了输出重定向文件，但错误信息显示在显示屏上。如果使用输出重定向，此时错误信息不会出现在重定向的文件中。</li>
<li>2    <code>STDERR</code>   标准错误。默认情况下，<code>STDERR</code>文件描述符会和<code>STDOUT</code>文件描述符指向同样的地方（尽管分配给他们的文件描述符不同）。也就是说在默认情况下，错误信息也会显示在显示器上。但是<code>STDERR</code>不会随着<code>STDOUT</code>的重定向而发生改变。</li>
</ol>
</li>
<li><p>重定向错误。</p>
<ol>
<li><p>只重定向错误。可以选择只重定向错误信息，讲该文件描述符值放在重定向符号前（必须紧跟）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al badfile 2&gt; <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>这样的话只会把错误进行重定向，标准输出还是会出现在屏幕上。</p>
</li>
<li><p>重定向错误和数据。</p>
<ol>
<li><p>如果想要将两者标准输出和错误输出分开重定向。使用如下形式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ls</span> -al goodfile badfile 1&gt; test1 2&gt; test2</span><br></pre></td></tr></table></figure></li>
<li><p>如果想要将两者输出一起重定向，使用<code>&amp;&gt;</code>符号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ls</span> -al goodfile badfile &amp;&gt; <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>使用<code>&amp;&gt;</code>符号时，为了避免错误信息散落在输出文件中，相较于标准输出，bash shell自动赋予了错误信息更高的优先级，重定向后所有的错误信息会集中在开头。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="脚本中重定向输出"><a href="#脚本中重定向输出" class="headerlink" title="脚本中重定向输出"></a>脚本中重定向输出</h4><ol>
<li><p>临时重定向。如果有意在脚本中生成错误信息，可以将单独的一行输出重定向到<code>STDERR</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;error message&quot;</span> &gt;&amp;2</span><br></pre></td></tr></table></figure>
<p>这行把<code>echo</code>命令的输出重定向到<code>STDERR</code>中。</p>
</li>
<li><p>永久重定向。可以使用<code>exec</code>命令告诉shell在脚本执行期间重定向某个特定文件描述符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 2&gt;errorfile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;normal message&quot;</span></span><br><span class="line"><span class="built_in">exec</span> 1&gt;outputfile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;in output file&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;in error file&quot;</span> &gt;&amp;2</span><br></pre></td></tr></table></figure>
<h4 id="脚本中重定向输入"><a href="#脚本中重定向输入" class="headerlink" title="脚本中重定向输入"></a>脚本中重定向输入</h4></li>
<li><p>可以使用与脚本中重定向<code>STDOUT</code>和<code>STDERR</code>相同的方法来将<code>STDIN</code>从键盘重定向到其他位置。<code>exec</code>命令允许你将<code>STDIN</code>重定向到Linux系统上的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 0&lt; testfile</span><br></pre></td></tr></table></figure>
<h4 id="创建自己的重定向"><a href="#创建自己的重定向" class="headerlink" title="创建自己的重定向"></a>创建自己的重定向</h4></li>
<li><p>创建输出文件描述符。可以使用<code>exec</code>命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件描述符分配给一个文件，这个重定向就会一直有效，直到重新分配。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt;testfile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test message&quot;</span> &gt;&amp;3</span><br></pre></td></tr></table></figure></li>
<li><p>重定向文件描述符。你可以分配另外一个描述符给标准文件描述符，反之亦然。可以使用这个方法恢复以重定向的文件描述符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt;&amp;1</span><br><span class="line"><span class="built_in">exec</span> 1&gt;testfile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;In file&quot;</span></span><br><span class="line"><span class="built_in">exec</span> 1&gt;&amp;3</span><br></pre></td></tr></table></figure>
<p>上面这个例子先把3重定向到1的当前位置，然后把1重定向到testfile文件，现在<code>echo</code>命令的输出会出现在文件中，然后再把1重定向到3的位置，也就是恢复了原来的<code>STDOUT</code>。这是一种再脚本中临时重定向输出，然后恢复默认输出设置的常用方法。</p>
</li>
<li><p>创建输入文件描述符。相似的也可以临时重定向<code>STDIN</code>然后恢复</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 6&lt;&amp;0</span><br><span class="line"><span class="built_in">exec</span> 0&lt;testfile</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exec</span> 0&lt;&amp;6</span><br></pre></td></tr></table></figure></li>
<li><p>创建读写描述符。由于是对同一个文件进行读写，shell会维护一个内部指针，指明在文件中的当前位置，任何读写都会从文件指针上次的位置开始。需要特别小心，可以看下面这个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">exec</span> 3&lt;&gt; testfile</span><br><span class="line"><span class="built_in">read</span> line &lt;&amp;3</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Read: <span class="variable">$line</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a test line&quot;</span> &gt;&amp;3</span><br><span class="line">$ cat testfile</span><br><span class="line">This is the first line.</span><br><span class="line">This is the second line.</span><br><span class="line">This is the third line.</span><br><span class="line">$ ./test.sh</span><br><span class="line">ReAD: This is the first line.</span><br><span class="line">$ cat testfile</span><br><span class="line">This is the first line.</span><br><span class="line">This is a <span class="built_in">test</span> line</span><br><span class="line">ine.</span><br><span class="line">This is the third line.</span><br></pre></td></tr></table></figure>
<p>可以发现在对于testfile文件进行一次读取后，指针位于第二行的开头，这时写入的话会覆盖文件第二行的内容。</p>
</li>
<li><p>关闭文件描述符。如果创建了新的输入或输出文件描述符，shell会在脚本退出是自动关闭他们。如果需要手动关闭，将它重定向到特殊符号<code>&amp;-</code>。下面的这段代码允许会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt;testfile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test message&quot;</span> &gt;&amp;3</span><br><span class="line"><span class="built_in">exec</span> 3&gt;&amp;-</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;bad message&quot;</span> &gt;&amp;3</span><br></pre></td></tr></table></figure>
<p>如果随后在脚本中打开了同一个输出文件，shell会用一个新文件替换已有文件。（需要用<code>&gt;&gt;</code>）</p>
</li>
</ol>
<h4 id="列出打开的文件描述符"><a href="#列出打开的文件描述符" class="headerlink" title="列出打开的文件描述符"></a>列出打开的文件描述符</h4><ol>
<li><code>lsof</code>命令会列出整个linux系统打开的所有文件描述符。该命令会产生大量输出，会显示当前系统上打开的每个文件的有关信息。这包括后台运行的所有进程以及登录到系统的任何用户。有大量的参数可以过滤输出，<code>-p</code>运行输出<code>PID</code>，<code>-d</code>指定需要显示的文件描述符编号，<code>-a</code>用于对于多个选项的输出求交。</li>
</ol>
<h4 id="阻止命令输出"><a href="#阻止命令输出" class="headerlink" title="阻止命令输出"></a>阻止命令输出</h4><ol>
<li><p>如果想要丢弃某些输出。例如丢弃<code>STDERR</code>的输出，可以将其重定向到<code>/dev/null</code>文件。重定向到该位置的任何数据都会被丢掉。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al badfile testfile 2&gt; /dev/null</span><br></pre></td></tr></table></figure>
<p>这种方式可以丢弃报错信息。</p>
</li>
</ol>
<h4 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h4><p>linux系统有特殊的目录，专供临时文件使用。linux使用<code>/tmp</code>目录来存放不需要永久保存的文件。大多数linux发行版配置了系统在启动时自动删除<code>/tmp</code>目录的所有文件。系统上的任何用户都有权限在读写<code>/tmp</code>目录中的文件。</p>
<p><code>mktemp</code>命令可以用来创建临时文件，可以在<code>/tmp</code>目录中创建一个唯一的临时文件。会将文件的读写权限分配给文件的属主，并将用户设置为文件的属主，其他人没法访问它。</p>
<ol>
<li><p>创建本地临时文件。默认情况下<code>mktemp</code>会在本地创建一个文件。要用<code>mktemp</code>命令在本地目录中创建一个临时文件，只需要指定一个文件名模板就可以了。模板可以包含任意文本文件名，在文件名末尾加上6个x就行了。<code>mktemp</code>命令会用6个字符码替换这6个x，保证文件名在当前目录是唯一的。<code>mktemp</code>命令的输出是文件名（相对路径），在脚本中使用这个命令时，可能要将文件名保存在变量中，这样就可以继续引用了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tmpfile=$(mktemp test.xxxxxx)</span><br><span class="line"><span class="built_in">exec</span> 3&gt;<span class="variable">$tmpfile</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;first line&quot;</span> &gt;&amp;3</span><br><span class="line"><span class="built_in">exec</span> 3&gt;&amp;-</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;file contains:&quot;</span></span><br><span class="line">cat <span class="variable">$tmpfile</span></span><br><span class="line">rm -f <span class="variable">$tmpfile</span> 2&gt; /dev/null</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>/tmp</code>目录创建临时文件。<code>-t</code>选项会强制<code>mktemp</code>命令在系统的临时目录来创建该文件，此时<code>mktemp</code>返回临时文件的绝对路径。</p>
</li>
<li><p>创建临时目录。<code>-d</code>选项告诉<code>mktemp</code>命令创建一个临时目录。可以在这个临时目录下继续创建临时文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmpdir=$(mktemp -d dir.xxxxxx)</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$tmpdir</span></span><br><span class="line">tmpfile1=$(mktemp temp.xxxxxx)</span><br><span class="line">tmpfile2=$(mktemp temp.xxxxxx)</span><br></pre></td></tr></table></figure>
<h4 id="记录消息"><a href="#记录消息" class="headerlink" title="记录消息"></a>记录消息</h4></li>
<li><p>如果想要输出同时出现在显示屏和日志文件上，可以使用<code>tee</code>命令。<code>tee</code>从<code>STDIN</code>读取的数据发向两端，一端是<code>STDOUT</code>，另一端是命令行指定的文件<code>tee file</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date | tee testfile</span><br></pre></td></tr></table></figure>
<p>注意默认情况tee会覆盖输出文件，如果需要追加写入需要使用<code>-a</code>选项。</p>
</li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>shell输入输出处理</p><p><a href="https://afawa.github.io/2021/01/17/shell输入输出处理/">https://afawa.github.io/2021/01/17/shell输入输出处理/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Yiming He</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-01-17</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-01-19</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/shell-programming/">shell programming</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5ff82d83d7d501001255ad9d&amp;product=sticky-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/01/18/shell%E8%84%9A%E6%9C%AC%E6%8E%A7%E5%88%B6/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">shell脚本控制</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/08/shell%E8%84%9A%E6%9C%AC%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4/"><span class="level-item">shell脚本结构化命令</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "b1ca52f26a74bcbe7b06be9003ea757a",
            repo: "afawa.github.io",
            owner: "afawa",
            clientID: "ad49fd64876339d5ddc6",
            clientSecret: "c34cd6c177e1310c81d20ff9b5efea8c05b1a546",
            admin: ["afawa"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#shell-处理输入输出"><span class="level-left"><span class="level-item">1</span><span class="level-item">shell 处理输入输出</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#处理用户输入"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">处理用户输入</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#命令行参数"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">命令行参数</span></span></a></li><li><a class="level is-mobile" href="#特殊参数变量"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">特殊参数变量</span></span></a></li><li><a class="level is-mobile" href="#移动变量"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">移动变量</span></span></a></li><li><a class="level is-mobile" href="#处理选项"><span class="level-left"><span class="level-item">1.1.4</span><span class="level-item">处理选项</span></span></a></li><li><a class="level is-mobile" href="#读取用户输入"><span class="level-left"><span class="level-item">1.1.5</span><span class="level-item">读取用户输入</span></span></a></li></ul></li><li><a class="level is-mobile" href="#呈现数据"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">呈现数据</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#输入和输出"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">输入和输出</span></span></a></li><li><a class="level is-mobile" href="#脚本中重定向输出"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">脚本中重定向输出</span></span></a></li><li><a class="level is-mobile" href="#脚本中重定向输入"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">脚本中重定向输入</span></span></a></li><li><a class="level is-mobile" href="#创建自己的重定向"><span class="level-left"><span class="level-item">1.2.4</span><span class="level-item">创建自己的重定向</span></span></a></li><li><a class="level is-mobile" href="#列出打开的文件描述符"><span class="level-left"><span class="level-item">1.2.5</span><span class="level-item">列出打开的文件描述符</span></span></a></li><li><a class="level is-mobile" href="#阻止命令输出"><span class="level-left"><span class="level-item">1.2.6</span><span class="level-item">阻止命令输出</span></span></a></li><li><a class="level is-mobile" href="#创建临时文件"><span class="level-left"><span class="level-item">1.2.7</span><span class="level-item">创建临时文件</span></span></a></li><li><a class="level is-mobile" href="#记录消息"><span class="level-left"><span class="level-item">1.2.8</span><span class="level-item">记录消息</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux-command-line/"><span class="level-start"><span class="level-item">linux command line</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/programming-language/"><span class="level-start"><span class="level-item">programming language</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Yiming&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Yiming He</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>