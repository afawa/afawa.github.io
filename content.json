{"pages":[{"title":"About me","text":"简历测试","link":"/about/index.html"}],"posts":[{"title":"shell脚本构建","text":"构建基本shell脚本显示输出，引用变量 echo 命令，使用””和‘’进行区分 echo -n 随后的输出不会换行 $name，${name} 引用变量 ，使用\\$进行转义 命令替换 两种方法，反引号`和$( )格式 命令替换会创建一个子shell来运行对应的命令，所以无法使用在脚本中所创建的变量 在命令提示符下使用路径./运行命令的话，也会创建出子shell，要是运行命令的时候不加入路径，就不会创建子shell。如果使用的是shell内建命令，不会涉及子shell 重定向 &gt;&gt; 重定向输出并且不会清空文件原有的内容 内联输入重定向符号 &lt;&lt;，除了这个符号，你必须指定一个文本标记来划分输入数据的开始和结尾 12345$ wc &lt;&lt; EOF&gt; test string 1&gt; test string 2&gt; test string 3&gt; EOF 执行数学运算 第一种方式使用expr命令，例如expr 1 + 5，expr 2 \\* 5，在shell中使用需要进行命令替换 第二种方式使用方括号，例如 var=$[1 + 5]，var=$[2 * 5] bash shell 原生只支持整形运算 在bash中使用浮点运算的一种方式是使用内建计算器bc，在脚本中使用bc，可以使用命令替换+管道的方式，例如 123var1=100var2=45var=$(echo &quot;scale=4; $var1 / $var2&quot; | bc) 或者使用内联输入重定向，例如 1234567var=$( bc &lt;&lt; EOFscale=4a1 = ($var1 * $var2)b1 = ($var3 * $var4)a1 + b1EOF) 退出脚本 linux提供了专门的变量$?来存储上一个命令的退出状态码，可以直接用echo $?查看 默认情况下shell脚本会以脚本的最后一个命令的退出码退出 可以使用exit命令指定退出码 退出码范围 0~255","link":"/2021/01/08/shell%E8%84%9A%E6%9C%AC%E6%9E%84%E5%BB%BA/"},{"title":"shell脚本结构化命令","text":"结构化命令if-then 语句1234if commandthen commandsfi 如果if后的命令的推出码是0，则会运行then部分。 运行if语句中的错误信息依然会显示，可以用某些方法避免 另一种形式 123if command; then commandsfi if-then-else 语句 123456if commandthen commandselse commandsfi if中的语句的退出码不为0时，运行else中的语句 嵌套if123456if command1then commandselif command2 commandsfi test 命令如果test命令中列出的条件成立，test命令就会退出并返回退出码0。如果condition部分本身为空，那么test以非零返回。 1234567# test 命令test condition# test 命令结合if-elseif test conditionthen commandsfi bash 提供了另一种测试方式，不需要声明test命令。方括号定义了测试条件，第一个方括号后和第二个方括号前必须加上一个空格。 1234if [ condition ]then commandsfi test可以测试一个变量是否为空，不为空则返回0 数值比较 n1 arg n2，其中n1，n2是数值，arg是选项，arg包括 -eq, -ge, -gt, -le, -lt, -ne （相等，大于等于，大于，小于等于，小于，不等于）。 bash shell只能处理整数，test命令不能处理浮点数。 字符串比较 字符串相等性。str1 = str2 判断两个字符串是否相等，str1 != str2 判断两个字符串是否不相等 字符串顺序。str1 \\&gt; str2 , str1 \\&lt; str2。大于号小于号必须使用转义，不然会被理解成重定向符号。在test中，根据ASCII标准进行排序，sort和test对于大写小写的判断是反的。 字符串大小。-n str1 检查str1的长度是否为0 ，-z str1 检查str1的长度是否不为0。 文件比较 检查目录。-d file，检查file是否存在并是一个目录。 检查对象是否存在。-e file，检查file是否存在。 检查文件。-f file，检查file是否存在并是一个文件。 检查是否可读。-r file，检查file是否存在并可读。 检查空文件。-s file，检查file是否存在并非空。 检查是否可写。-w file，检查file是否存在并可写。 检查文件是否可以执行。-x file，检查file是否存在并可执行。 检查所属关系。-O file，检查file是否存在并属于当前用户所有。 检查默认属主关系。-G file，检查file是否存在并且默认组与当前用户相同。 检查文件日期。file1 -nt file2，检查file1是否比file2新。file1 -ot file2，检查file1是否比file2旧。 复合条件测试 允许使用 &amp;&amp; 和 || 连接多个condition。 if-then 高级特性 双括号。双括号命令运行在比较过程中使用高级数学符号。（几乎是所有c中的运算都能用）并且在双括号中不需要对&gt;和&lt;进行转义。 12345var=10if (( var ** 2 &lt; 1000 ))then var=$(( var-- ))fi 双方括号。双方括号中可以使用模式匹配。例如 [[ $USER == r* ]]，这里使用了==，右边的r*就是一个模式。 case 命令类似switch命令，格式如下 12345case variable inpattern1 | pattern2) commands1;;pattern3) commands2;;*) commands3;;esac for 命令1234for var in listdo commandsdone 在list参数中，需要提供迭代中要用到的一系列值。 读取列表中的值。for命令最基本的用法就是遍历for命令本身所定义的一系列值。在最后一次迭代后，$test的值会在shell脚本的剩余部分一直保持有效。 1234for test in aaa bbb ccc ddddo echo $testdone 读取列表中的复杂值。 如果列表中的值存在单引号，可以用如下两种方式：1.使用转义，2.使用双引号。 1234for test in I don\\'t know if &quot;this'll&quot; workdo echo $testdone 如果存在空格，必须使用双引号把这个值框起来。 从变量读取列表 123456list=&quot;aaa bbb ccc&quot;list=$list&quot; ddd&quot;for test in listdo echo $testdone 从命令读取值 12345file=testfile.txtfor test in $(cat $file)do echo $testdone 更改字段分隔符 内部字段分隔符，IFS环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字符当作字段分隔符：1. 空格，2. 制表符，3. 换行符 修改IFS，例如，IFS=$'\\n'。这里注意用$'\\n'，$'string'是用来表示带转义序列的字符串文字的语法 (called ANSI C-quoted strings) 指定多个的时候只需要简单拼接。IFS=$'\\n':;&quot; 用通配符读取目录 必须使用通配符，它会强制shell使用文件扩展匹配。 1234567for file in /home/yiming/*do if [ -d &quot;$file&quot; ] then echo &quot;$file is a directory&quot; fidone 注意这里”$file”应对文件名带空格的情况。同时可以使用多个通配符拼接，通配符加目录一起使用 C风格for1for (( variable assignment ; condition ; iteration process )) 变量赋值可以用空格 条件中的变量不已美元开头 迭代过程的算式不使用expr表达式 123456789for (( i=1 ; i&lt;=10 ; i++ ))do echo $idonefor (( a=1, b=10; a&lt;=10; a++, b-- ))do echo &quot;$a - $b&quot;done while 命令 基本格式 1234while test commanddo other commanddone 这里的test command和if-else语句一模一样。 12345var1=10while [ $var -gt 1 ]do var1=$(( var - 1 ))done 使用多个测试命令 while 命令允许你在while语句定义多个测试命令，只有最后一个测试命令的退出状态码会被用来决定什么时候退出循环。 123456var1=10while echo $var1 [ $var1 -ge 0 ]do var=$(( var1 - 1 ))done until 命令 1234until test commandsdo other commandsdone 本质是和while相反的语句。 循环控制 break命令。直接使用break命令会跳出当前正在执行的循环。可以使用 break n来指定跳出的层数，默认n=1也就是跳出当前循环。 continue命令。和break相同，可以使用continue n的语法指定继续执行哪一级的循环。 处理循环的输出在shell脚本中可以对循环的输出使用管道或进行重定向。可以通过在done命令后添加一个处理命令来实现。 12345678910111213141516171819# 重定向例子for (( a=1; a&lt;=10; a++))do echo $adone &gt; output.txt# 也可以使用重定向进行输入，然后用read命令处理input=&quot;users.csv&quot;while IFS=',' read -r userid namedo echo &quot;adding $userid&quot; useradd -c &quot;$name&quot; -m $useriddone &lt; &quot;$input&quot;# 管道例子for (( a=1; a&lt;=10; a++))do echo $adone | sort","link":"/2021/01/08/shell%E8%84%9A%E6%9C%AC%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4/"},{"title":"shell输入输出处理","text":"shell 处理输入输出处理用户输入命令行参数 读取参数。 bash shell会将一些称为位置参数的特殊变量分配给输入到命令行中的所有参数。位置参数是标准的数字：$0是程序名，$1是第一个参数，一直到$9。如果参数不止9个，需要使用${10}这种方式使用参数。 如果参数值中包含空格，需要使用引号来（单引号或者双引号），将文本字符串作为参数传递时，引号并非数据的一部分，只是表明数据的起止位置。 1$ ./test.sh &quot;Rich Blum&quot; 读取脚本名。可以使用$0获取shell在命令行启动的脚本名。但是这里存在一个问题，如果使用另一个命令来运行shell脚本，命令会和脚本名混在一起，出现在$0参数中。并且如果使用脚本完整路径使用脚本时，会显示脚本的绝对路径。为了只使用脚本的名称，可以使用basename命令。 1name=$(basename $0) 测试参数。需要在使用之前检查是否传入了对应量的参数。下面是一个例子。 123456if [ -n &quot;$1&quot; ]then echo $1else echo &quot;not define&quot;fi 特殊参数变量 参数统计。$#变量中存储了脚本运行时携带的命令行参数的个数。如果想要之间使用最后一个参数，可以使用${!#}来引用。 抓取所有数据。$@和$*可以用来对于参数进行遍历。 $*变量会将命令行上提供的所有参数保存为一个单词。 $@变量会将命令行上提供的所有参数当作同一个字符串中的多个独立的单词。（用于遍历十分方便） 移动变量 shift 命令可以用来操作命令行参数，默认情况下它会将每个参数向左移动一个位置，$3 -&gt; $2 并且原来的$1直接消失，$0内依然是脚本名。当不知道有多少参数时，可以用它配合while进行遍历。例子如下 12345while [ -n &quot;$1&quot; ]do echo $1 shiftdone 同时也可以对于shift指定一个数字，代表移动的数量，shift 2就是移动两个变量。 处理选项 查找选项 处理简单选项。可以使用case语句配合shift进行选项提取。例如 123456789while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found -a&quot; ;; -b) echo &quot;Found -b&quot; ;; *) echo &quot;$1 is not a option&quot; ;; esac shiftdone 分离参数和选项。如果在脚本中同时使用选项和参数，Linux中处理这个问题的标准方式是用特殊字符将两者分开。对Linux来说，这个特殊字符是--。shell会用--来表明选项列表的结束，之后的都会被当作命令行参数。实现时只需要在case语句中加入对于--的判断。 12345678910111213141516 while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found -a&quot; ;; -b) echo &quot;Found -b&quot; ;; --) shift break ;; *) echo &quot;$1 is not a option&quot; ;; esac shift done for para in $@ do echo &quot;Parameter $para&quot; done 处理带值的选项。例子如下 1234567891011121314151617while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found -a&quot; ;; -b) para=&quot;$2&quot; echo &quot;Found -b, parameter=$para&quot; shift ;; --) shift break ;; *) echo &quot;$1 is not a option&quot; ;; esac shiftdonefor para in $@do echo &quot;Parameter $para&quot;done 这里-b选项需要一个额外的参数。 使用getopt命令。上面的内容无法处理更加复杂的需求，例如我们想要把多个选项放到一个参数中 1$ ./test.sh -ac 这样的操作需要使用getopt选项 getopt格式。getopt optstring parameters，其中optstring定义了有效的选项字母，还定义了哪些选项需要参数值。在optstring中列出每个需要参数值的字母，然后再每个需要参数值的选项字母后加一个冒号。getopt会根据optstring进行解析。例子如下 123$ getopt ab:cd -a -b test1 -cd test2 test3-a -b test1 -c -d -- test2 test3$ 如果指定了一个不在optstring中的选项，默认情况下会产生一条错误信息， 1234$ getopt ab:cd -a -b test1 -cde test2 test3getopt: invalid option -- 'e'-a -b test1 -c -d -- test2 test3$ 可以在命令后加入-q选项 123$ getopt -q ab:cd -a -b test1 -cde test2 test3-a -b test1 -c -d -- test2 test3$ 在脚本中使用getopt。方法是使用getopt命令生成的格式化后的版本来替换已有的命令行选项和参数。需要使用set命令。set命令的选项之一是--，它会将命令行参数替换为set命令的命令行值。 12345678910111213141516171819202122#!/bin/bashset -- $(getopt -q ab:cd &quot;$@&quot;)while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found -a&quot; ;; -b) para=&quot;$2&quot; echo &quot;Found -b, parameter=$para&quot; shift ;; -c) echo &quot;Found -c&quot; ;; -d) echo &quot;Found -d&quot; ;; --) shift break ;; *) echo &quot;$1 is not a option&quot; ;; esac shiftdonefor para in $@do echo &quot;Parameter $para&quot;done 但是getopt任然存在一个小问题：getopt并不擅长处理带引号和空格的场景，对于上述代码，下面的方法可以解决这个问题。 12345678$ ./test.sh -a -b test1 -cd &quot;test2 test3&quot; test4Found -aFound -b, parameter=test1Found -cFound -dParameter 'test2Parameter test3'parameter 'test4' getopts命令。与getopt不同，前者将命令行上选项和参数处理后只生成一个输出，而getopts命令能够和已有的shell参数变量配合。每次调用它时，它一次处理命令行上检测的一个参数。处理完所有参数后，它会退出并返回一个大于0的退出码。可以和循环命令结合使用。命令格式如下： 1getopts optstring variable 其中optstring和getopt命令类似，注意如果需要去掉错误信息的话，可以在optstring之前加一个冒号。getopts命令将当前参数保存在命令行中定义的variable中。getopts命令会用到两个环境变量，如果选项需要跟一个参数值，OPTARG环境变量就会保存这个值。OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。 12345678910#!/bin/bashwhile getopts :ab:c optdo case &quot;$opt&quot; in a) echo &quot;Found -a&quot; ;; b) echo &quot;Found -b, parameter $OPTARG&quot; ;; c) echo &quot;Found -c&quot; ;; *) echo &quot;Unknown option $opt&quot; ;; esacdone 注意对于$OPTARG如果包含空格需要用引号包裹。 1234$ ./test.sh -ab &quot;test1 test2&quot; -cFound -aFound -b, parameter test1 test2Found -c 初次之外，getopts将命令行上找到的所有未定义的选项统一输出为问号。 12345$ ./test.sh -ab &quot;test1 test2&quot; -c -dFound -aFound -b, parameter test1 test2Found -cUnknown option ? getopts只会处理选项参数，可以使用shift结合OPTIND环境变量来解析后续参数。 1234567891011121314151617#!/bin/bashwhile getopts :ab:c optdo case &quot;$opt&quot; in a) echo &quot;Found -a&quot; ;; b) echo &quot;Found -b, parameter $OPTARG&quot; ;; c) echo &quot;Found -c&quot; ;; *) echo &quot;Unknown option $opt&quot; ;; esacdoneshift $[ $OPTIND - 1 ]for para in &quot;$@&quot;do echo &quot;Parameter $para&quot;done 这样就可以处理了， 12345678910111213$ ./test.sh -ab &quot;test1 test2&quot; -c test3 test4Found -aFound -b, parameter test1 test2Found -cParameter test3Parameter test4$ ./test.sh -ab test1 test2 -c test3 test4Found -aFound -b, parameter test1Parameter test2Parameter -cParameter test3Parameter test4 不过需要注意getopts解析时需要把选项放在参数之前，这点和getopt不一样，对于getopt或默认把参数整理出来放在最后。 12$ getopt ab:c -ab test1 test2 -c test3 test4 -a -b test1 -c -- test2 test3 test4 读取用户输入 基本的读取。read命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后read命令会将数据存在一个变量里。 12read nameecho &quot;I'm $name&quot; read命令包含了-p选项能够在命令行指定提示符 12read -p &quot;Who are you?&quot; nameecho &quot;I'm $name&quot; read可以指定多个变量，输入的每个数值都会分配给变量列表中的下一个变量，如果变量数量不够，剩下的数据就全部分配给最后一个变量。read也可以不指定变量，这样的话收到的任何数据都会在特殊环境变量REPLY中。 超时，限定数目。 -t选项指定了read命令等待输入的秒数，当计时器过期之后，read命令返回一个非零退出码。 也可以不对输入过程计时，而是让read命令来统计输入的字符数。使用-n选项加上一个数字代表接受多少个字符。 隐藏输入。使用-s命令避免read命令中输入的数据出现在显示器上。 从文件中读取。每次使用read都会读取文件的一行，直到文件末尾，使用方式就是 cat + 管道 + while + read 。（done + 重定向也是可以的） 123456count=1cat test.txt | while read linedo echo &quot;$count $line&quot; count=$[ $count + 1 ]done 呈现数据输入和输出 标准文件描述符。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符。bash shell保留了前三个文件描述符。 0 STDIN 标准输入。 1 STDOUT 标准输出。当命令生成错误信息时，shell创建了输出重定向文件，但错误信息显示在显示屏上。如果使用输出重定向，此时错误信息不会出现在重定向的文件中。 2 STDERR 标准错误。默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给他们的文件描述符不同）。也就是说在默认情况下，错误信息也会显示在显示器上。但是STDERR不会随着STDOUT的重定向而发生改变。 重定向错误。 只重定向错误。可以选择只重定向错误信息，讲该文件描述符值放在重定向符号前（必须紧跟） 1$ ls -al badfile 2&gt; test 这样的话只会把错误进行重定向，标准输出还是会出现在屏幕上。 重定向错误和数据。 如果想要将两者标准输出和错误输出分开重定向。使用如下形式 1$ls -al goodfile badfile 1&gt; test1 2&gt; test2 如果想要将两者输出一起重定向，使用&amp;&gt;符号 1$ls -al goodfile badfile &amp;&gt; test 使用&amp;&gt;符号时，为了避免错误信息散落在输出文件中，相较于标准输出，bash shell自动赋予了错误信息更高的优先级，重定向后所有的错误信息会集中在开头。 脚本中重定向输出 临时重定向。如果有意在脚本中生成错误信息，可以将单独的一行输出重定向到STDERR。 1echo &quot;error message&quot; &gt;&amp;2 这行把echo命令的输出重定向到STDERR中。 永久重定向。可以使用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符。 12345exec 2&gt;errorfileecho &quot;normal message&quot;exec 1&gt;outputfileecho &quot;in output file&quot;echo &quot;in error file&quot; &gt;&amp;2 脚本中重定向输入 可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。exec命令允许你将STDIN重定向到Linux系统上的文件。 1exec 0&lt; testfile 创建自己的重定向 创建输出文件描述符。可以使用exec命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件描述符分配给一个文件，这个重定向就会一直有效，直到重新分配。 12exec 3&gt;testfileecho &quot;test message&quot; &gt;&amp;3 重定向文件描述符。你可以分配另外一个描述符给标准文件描述符，反之亦然。可以使用这个方法恢复以重定向的文件描述符。 1234exec 3&gt;&amp;1exec 1&gt;testfileecho &quot;In file&quot;exec 1&gt;&amp;3 上面这个例子先把3重定向到1的当前位置，然后把1重定向到testfile文件，现在echo命令的输出会出现在文件中，然后再把1重定向到3的位置，也就是恢复了原来的STDOUT。这是一种再脚本中临时重定向输出，然后恢复默认输出设置的常用方法。 创建输入文件描述符。相似的也可以临时重定向STDIN然后恢复 1234567exec 6&lt;&amp;0exec 0&lt;testfilewhile read linedo echo $linedoneexec 0&lt;&amp;6 创建读写描述符。由于是对同一个文件进行读写，shell会维护一个内部指针，指明在文件中的当前位置，任何读写都会从文件指针上次的位置开始。需要特别小心，可以看下面这个例子。 1234567891011121314151617$ cat test.sh#!/bin/bashexec 3&lt;&gt; testfileread line &lt;&amp;3echo &quot;Read: $line&quot;echo &quot;This is a test line&quot; &gt;&amp;3$ cat testfileThis is the first line.This is the second line.This is the third line.$ ./test.shReAD: This is the first line.$ cat testfileThis is the first line.This is a test lineine.This is the third line. 可以发现在对于testfile文件进行一次读取后，指针位于第二行的开头，这时写入的话会覆盖文件第二行的内容。 关闭文件描述符。如果创建了新的输入或输出文件描述符，shell会在脚本退出是自动关闭他们。如果需要手动关闭，将它重定向到特殊符号&amp;-。下面的这段代码允许会报错。 1234exec 3&gt;testfileecho &quot;test message&quot; &gt;&amp;3exec 3&gt;&amp;-echo &quot;bad message&quot; &gt;&amp;3 如果随后在脚本中打开了同一个输出文件，shell会用一个新文件替换已有文件。（需要用&gt;&gt;） 列出打开的文件描述符 lsof命令会列出整个linux系统打开的所有文件描述符。该命令会产生大量输出，会显示当前系统上打开的每个文件的有关信息。这包括后台运行的所有进程以及登录到系统的任何用户。有大量的参数可以过滤输出，-p运行输出PID，-d指定需要显示的文件描述符编号，-a用于对于多个选项的输出求交。 阻止命令输出 如果想要丢弃某些输出。例如丢弃STDERR的输出，可以将其重定向到/dev/null文件。重定向到该位置的任何数据都会被丢掉。 1ls -al badfile testfile 2&gt; /dev/null 这种方式可以丢弃报错信息。 创建临时文件linux系统有特殊的目录，专供临时文件使用。linux使用/tmp目录来存放不需要永久保存的文件。大多数linux发行版配置了系统在启动时自动删除/tmp目录的所有文件。系统上的任何用户都有权限在读写/tmp目录中的文件。 mktemp命令可以用来创建临时文件，可以在/tmp目录中创建一个唯一的临时文件。会将文件的读写权限分配给文件的属主，并将用户设置为文件的属主，其他人没法访问它。 创建本地临时文件。默认情况下mktemp会在本地创建一个文件。要用mktemp命令在本地目录中创建一个临时文件，只需要指定一个文件名模板就可以了。模板可以包含任意文本文件名，在文件名末尾加上6个x就行了。mktemp命令会用6个字符码替换这6个x，保证文件名在当前目录是唯一的。mktemp命令的输出是文件名（相对路径），在脚本中使用这个命令时，可能要将文件名保存在变量中，这样就可以继续引用了。 1234567tmpfile=$(mktemp test.xxxxxx)exec 3&gt;$tmpfileecho &quot;first line&quot; &gt;&amp;3exec 3&gt;&amp;-echo &quot;file contains:&quot;cat $tmpfilerm -f $tmpfile 2&gt; /dev/null 在/tmp目录创建临时文件。-t选项会强制mktemp命令在系统的临时目录来创建该文件，此时mktemp返回临时文件的绝对路径。 创建临时目录。-d选项告诉mktemp命令创建一个临时目录。可以在这个临时目录下继续创建临时文件。 1234tmpdir=$(mktemp -d dir.xxxxxx)cd $tmpdirtmpfile1=$(mktemp temp.xxxxxx)tmpfile2=$(mktemp temp.xxxxxx) 记录消息 如果想要输出同时出现在显示屏和日志文件上，可以使用tee命令。tee从STDIN读取的数据发向两端，一端是STDOUT，另一端是命令行指定的文件tee file。 1date | tee testfile 注意默认情况tee会覆盖输出文件，如果需要追加写入需要使用-a选项。","link":"/2021/01/17/shell%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/"},{"title":"shell脚本控制","text":"shell 脚本控制处理信号 常见信号。 信号 值 描述 1 SIGHUP 挂起进程 2 SIGINT 终止进程 3 SIGQUIT 停止进程 9 SIGKILL 无条件终止 15 SIGTERM 尽可能终止 17 SIGSTOP 无条件停止，但不是终止 18 SIGTSTP 停止或暂停，但不是终止 19 SIGCONT 继续运行停止的进程 生成信号。bash shell运行用键盘上的组合键生成两种基本的信号。 中断进程。Ctrl+C组合键生成SIGINT，并将这个信号发送给在当前shell中运行的所有进程。 暂停进程。Ctrl+Z组合键生成SIGTSTP，停止shell中运行的任何进程。 1234$ sleep 100^Z[1]+ Stopped sleep 100$ 方括号中的数字是shell分配的作业号。如果shell会话中有已停止的作业，在退出shell时会提醒。 1234$ exitlogoutThere are stopped jobs.$ 被停止的进程可以使用ps命令查看。如果仍然想要退出只需要在输入一次exit命令，也可以使用kill命令手动终止。 123$ kill -9 141$[1]+ Killed sleep 100 捕获信号。trap命令允许你来指定shell脚本监看并从shell中拦截的linux信号。如果脚本收到了trap命令中列出的信号，该信号不再由shell处理，而是交由本地处理。 1trap commands signals 列出想要执行的命令，以及一组由空格分开的待捕获的信号。可以用数值或者信号名来指定信号。下面是一个例子 12345678trap &quot;receive a Ctrl+C&quot; SIGINTcount=1while [ $count -le 10 ]do echo &quot;Loop #$count&quot; sleep 1 count=$[ $count + 1 ]done 在上面的循环执行的过程中按Ctrl+C或显示receive a Ctrl+C。 捕获脚本退出。要捕获shell脚本的退出，只要在trap命令后加上EXIT信号就可以。 修改或移除捕获。 修改。只需要重新使用trap命令即可 移除。只需要在trap命令与希望恢复行为的信号列表之间加上--就可以了。也可以在trap命令后使用单破折号来恢复信号的默认行为。 后台运行脚本 后台运行脚本。只需要在命令后加上&amp;就可以了，注意这时脚本仍然会使用显示屏显示STDOUT和STDERR消息（重定向很重要）。 运行多个后台脚本。对于每个后台运行的进程都会分配作业号和进程号，可以使用ps命令查看，每一个后台进程都和终端会话联系在一起，如果终端会话退出。那么后台进程也会退出。（如果使用了后台进程并且打算退出进程，只有某些终端仿真器会在退出时提醒） 在非控制台下运行脚本可以使用nohup命令使得后台脚本能够在终端退出后继续运行。nohup命令的格式如下 1$ nohup test.sh &amp; 和普通后台进程一样，shell会给命令分配一个作业号，linux系统会为其分配一个PID号。区别在于，使用nohup时，如果关闭该会话，脚本会忽略终端会话发来的SIGHUP信号。同时进程会把STDOUT和STDERR的输出自动重定向到名为nohup.out的文件中。 作业控制 查看作业。jobs命令查看当前正在处理的作业。jobs命令会显示当前已停止/运行中的作业，以及作业号和命令。可以加上-l选项来显示作业的PID。jobs的输出如下 123$ jobs -l[1]+ 2333 Stopped ./test.sh [2]- 1314 Running ./test.sh &gt; test.out &amp; 输出中的+代表这个作业被当作默认作业。在使用作业控制命令时，如果未指定作业号，改作业就会被当作操作对象。当默认作业完成处理之后，-号的作业就成为下一个默认作业。任何时候都只有一个带+和一个带-的作业。 重启停止的作业。 后台模式重启。使用bg命令加上作业号（注意是作业号） 前台模式重启。使用fg命令加上作业号 调整谦让度linux中，由shell启动的所有进程的调度优先级默认都是相同的。调度优先级是一个整数值，从-20（最高优先级）到19（最低优先级）。默认情况下，bash shell以优先级0来启动所有进程。 nice命令。nice命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级允许，只要用nice命令的-n选项就可以了。 1$ nice -n 10 ./test.sh &gt; test.out &amp; 通过ps命令可以发现进程的NI值被设置为10。但是如果想要提高某个命令的优先级，会出现如下输出 12345$ nice -n -10 ./test.sh &gt; test.out &amp; [1] 2333$ nice: cannot set niceness: Permission denied [1]+ Done nice -n -10 ./test.sh &gt; test.out $ nice命令组织普通用户提高优先级，注意这里指定的命令执行了只是nice命令失败了。 renice命令。renice命令可以改变正在运行的程序的优先级， 1$ renice -n NI -p PID 通过-n选项指定优先级，-p选项指定PID即可。和nice命令一样renice也存在一些限制： 只能对于属于你的进程使用renice 只能通过renice命令降低优先级 root用户可以随意调整 定时运行程序用at命令来计划执行作业at命令会将作业提交到队列中，指定shell何时运行该作业。at的守护进程atd会以后台模式运行，检查作业队列来运行作业。atd守护进程会检查系统上的一个特殊目录（通常位于/var/spool/at）来获取用at命令提交的作业。默认情况下，atd守护进程会每60s检查一下这个目录。有作业时，atd守护进程会检查作业设置运行的时间。如果时间和当前时间匹配，atd守护检查就会运行此作业。 at命令的格式。 1at [-f filename] time 默认情况下，at命令读取STDIN的输入，可以使用-f选项指定脚本。time参数指定了何时运行该作业。如果时间已经错过，at命令会在第二天那个时间运行指定的作业。at命令可以识别多种时间的格式 标准的小时分钟格式。如10:10 AM/PM格式。如10:10 PM 特殊的可命名时间。如now、noon、midnight。 也可以用不同的日期格式指定特定的日期 标准日期格式。如MMDDYY、MM/DD/YY或DD.MM.YY。 文本日期。如Dec 25。 也可以使用时间增量。如当前时间+25min，明天10:15 PM，10:15+7天。 在你使用at命令时，作业会被提交到作业队列中，针对不同的优先级，存在26种不同的作业队列，作业队列通常用小写字母az和大写字母AZ来指代。字母排序越高，作业运行的优先级就越低。默认情况下提交到a队列，可以使用-q选项指定队列。 获取作业的输出。此时输出会以e-mail的形式发送，建议在脚本中加入重定向，如果输出不重要，可以使用at的-M选项来屏蔽作业的输出信息。 列出、删除等待的作业。 atq命令可以查看当前正在等待的作业。 atrm命令通过指定作业号来删除在队列中等待的作业。 安排定期执行的脚本linux使用cron程序来安排要定期执行的作业。 cron时间表。cron时间表采用一种特殊的格式来指定作业何时运行。格式如下： 1min hour dayofmonth month dayofweek command cron时间表允许你用特定值、取值范围（比如1-5）或者时通配符（*）来指定条目。下面是几个例子 123456789101112131415#在凌晨00:01运行1 0 * * * /home/yiming/test.sh#每个工作日23:59都进行备份作业23 59 * * 1-5 /home/yiming/test.sh23 59 * * 1,2,3,4,5 /home/yiming/test.sh#每分钟运行一次命令*/1 * * * * /home/yiming/test.sh#每个月的1号14:10运行10 14 1 * * /home/yiming/test.sh#每个月最后一天的00:01运行1 0 * * * [[ &quot;$(date +%d -d tomorrow)&quot; == &quot;01&quot; ]] &amp;&amp; /home/yiming/test.sh 命令列表必须指定要运行提交的命令或脚本的全路径名。cron会用提交作业的账号运行该脚本。 创建cron时间表。使用-l选项列出当前用户已有的时间表。使用-e选项添加cron时间表。 浏览cron目录。如果对于脚本运行的时间精度要求不高，使用预配置的cron脚本目录更方便，有四个/etc/cron.hourly/ /etc/cron.dayly/ /etc/cron.weekly/ /etc/cron.monthly/，直接把脚本复制到对应文件夹下即可。 anacron程序。cron程序默认linux一直开机，如果出现了关机后开机错过时间的情况不会重新执行。这个问题可以使用anacron程序解决，anacron程序只会处理位于cron目录下的程序，例如/etc/cron.monthly（不会处理/ect/cron.hourly下的程序）。他用时间戳来决定作业是否正常运行了。时间戳位于/var/spool/anacron。 使用新shell启动脚本可以将每次打开shell时需要运行的shell脚本放在$HOME/.bashrc文件中。","link":"/2021/01/18/shell%E8%84%9A%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"title":"shell脚本中使用函数","text":"shell脚本使用函数基本的脚本函数创建函数有两种形式可以用来在bash shell中创建函数。 第一种格式采用关键字function，后跟分配给该代码块的函数名。 123function name { commands} name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。 第二种格式更接近于其他编程语言中定义函数的方法。 123name() {commands} 函数名后的括号表明正在定义一个函数。 使用函数12345678910#!/bin/bashfunction func1 { echo &quot;example of function&quot;}count=1while [ count -le 5 ]do func1 count=$[ $count + 1 ]done 直接使用函数名调用即可，注意函数的声明一定要在函数调用之前。如果定义了两个相同名称的函数，后面的函数会覆盖前面的函数，并且不会出现报错。 函数返回值bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出码。 默认退出状态码默认情况下，函数的退出码时函数中最后一条命令返回的退出状态码。在函数执行后，可以用标准变量$?来确定函数的退出状态码。 123456789function func1 { echo &quot;normal command&quot; ls -l badfile}function func2 { ls -l badfile echo &quot;normal&quot;} 执行func1得到的函数返回值是1，因为函数的最后一条命令没有正常退出，但是运行func2时返回值为0，即使在运行func2的时候有命令没有正常退出。所以使用函数的默认返回值是很危险的。 使用return命令bash shell使用return命令来退出函数并返回特定的退出状态码。 12345function db1 { read -p &quot;Enter a value:&quot; value echo &quot;doubling the value&quot; return $[ $value * 2 ]} 采用这种方式时需要注意两点 函数一结束就取返回值，否则$?变量会被覆盖 退出码必须是0~255 使用函数输出可以把函数的输出保存在变量中，例如result=$(func)这种方式。 12345function db1 { read -p &quot;Enter a value:&quot; value echo $[ $value * 2 ]}result=$(db1) 这种方法比较泛用。 在函数中使用变量向函数传递参数bash shell会将函数当作小型脚本来对待，这意味着可以像普通脚本那样向函数传递参数。函数可以使用标准的参数函数变量来表示命令行上传给函数的参数（$0 $1 $#）。在脚本中指定函数时，必须将参数和函数放在同一行，例如 1func1 $value1 10 下面是一个例子 12345678910function addem { if [ $# -eq 0 ] || [ $# -gt 2 ] then echo -1 elif [ $# -eq 1 ] echo $[ $1 + $1 ] else echo $[ $1 + $2 ] fi} 由于函数使用特殊参数环境变量作为自己的参数值，因此它无法直接获取脚本在命令行中的参数值。 在函数中处理变量 全局变量。如果在脚本的主体部分定义了一个全局变量，那么可以在函数内读取它的值。类似的，如果在函数内定义了一个全局变量，可以在脚本的主体部分读取它的值。默认情况下，在脚本中定义的任何变量都是全局变量。 1234567function db1 { value=$[ $value * 2 ]}read -p &quot;Enter a value:&quot; valuedb1echo &quot;The new value is: $value&quot; 这样其实很危险，如果想要在不同的shell脚本中使用函数的话。要求需要知道函数中使用了哪些变量。 局部变量。想要声明局部变量，只要在变量声明的前面加上local就可以了，也可以在变量的赋值时使用local。 数组变量和函数向函数传递数组参数将数组变量当作单个参数传递的话，并不会起作用 12345678function testit { echo &quot;The parameter are: $@&quot; thisarray=$1 echo &quot;The received array is ${thisarray[*]}&quot;}myarray=(1 2 3 4 5)echo &quot;The original array is: ${myarray[*]}&quot;testit myarray 这段代码的输出如下 123The origin array is: 1 2 3 4 5The parameter are: 1The received array is 1 这表明如果试图将数组变量作为函数参数，函数只会取数组变量的第一个值。 要解决这个问题，必须将该数组变量的值分解为单个的值，然后将这些值作为参数。在函数内部，可以将这些值重新组合成一个新的变量。下面是一个例子。 12345678910111213141516#!/bin/bashfunction testit { local newarray local sum=0 newarray=($(echo &quot;$@&quot;)) echo &quot;The new array value is: ${newarray[*]}&quot; for value in ${newarray} do sum=$[ $sum + $value ] done echo $sum}myarray=(1 2 3 4 5)echo &quot;The original array is: ${myarray[*]}&quot;result=$(testit ${myarray[*]})echo &quot;result is $result&quot; 这样的输出就是正确的了。 从函数返回数组函数用echo语句来按照顺序输出数组中的值，在调用处进行处理就可以了。 1234567891011121314151617181920#!/bin/bashfunction arraydblr { local origarray local newarray local elements local i origarray=($(echo &quot;$@&quot;)) newarray=($(echo &quot;$@&quot;)) elements=$[ $# - 1 ] for (( i=0; i &lt;= $elements; i++ )) do newarray[$i]=$[ ${origarray[$i]} * 2 ] done echo ${newarray[*]}}myarray=(1 2 3 4 5)echo &quot;The original array is: ${myarray[*]}&quot;result=($(testit ${myarray[*]}))echo &quot;The new array is: ${result[*]}&quot; 函数递归注意local的使用 12345678910function factorial { if [ $1 -eq 1 ] then echo 1 else local temp=$[ $1 - 1 ] local result=$(factorial $temp) echo $[ $result * $1 ] fi} 创建库使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令（./lib.sh命令没有用因为会创建新的shell运行，函数没有装载到当前的上下文）。source命令有个快捷的别名，点操作符，. ./lib.sh。 在命令行上使用函数在命令行上创建函数 单行方式在命令行创建函数。 1$ function div { echo $[ $1 / $2 ]; } 注意每条命令之后都要加上分号。 多行方式定义函数。 1234$ function div {&gt; echo $[ $1 / $2 ]&gt; }$ 小心函数名和已有的命令名重合。 在.bashrc中定义函数 直接在.bashrc中定义函数 定义在其他文件中，然后在.bashrc中使用source语句装载 1234if [ -r /home/yiming/lib.sh ]then . /home/yiming/lib.shfi","link":"/2021/01/19/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0/"},{"title":"sed,gawk基础与正则表达式","text":"sed基础，gawk基础，正则表达式sed 编辑器sed简单应用sed编辑器被称为流编辑器，流编辑器会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。sed可以根据命令来处理数据流中的数据，这些命令要么从命令行中输入，要么存储在一个命令文本文件中。sed编辑器会执行下列操作。 一次从输入中读取一行数据 根据所提供的编辑器命令匹配数据 按照命令修改流中的数据 将新的数据输出到STDOUT sed命令的格式如下 1sed options script file 根据选项可以修改sed命令的行为， -n。不产生命令输出，使用print命令来完成输出。 -e script。在处理输入时，将script中指定的命令添加到已有的命令中。（命令行输入，多个-e script组合） -f file。在处理输入时，将file中指定的命令添加到已有的命令中。（文件输入） 在命令行定义编辑器命令默认情况下，sed编辑器会将指定的命令应用到STDIN输入流上。可以直接通过管道输入sed编辑器进行处理。 123$ echo &quot;This is a test&quot; | sed 's/test/big test/' This is a big test$ 在上面的示例中使用管道对sed编辑器输入文本，然后使用s命令对于文本进行替换，这里的s/test/big test/代表把test全部替换成big test。 sed编辑器不会修改文本文件的数据，它只会将修改后的数据发送到STDOUT中。 在命令行使用多个编辑器命令要在sed命令行上执行多个命令时，使用-e选项 1234567891011121314151617181920212223$ cat data1.txtThe quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy dog.$ sed -e 's/brown/green/; s/dog/cat/' data1.txtThe quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.$ sed -e 's/brown/green/' -e 's/dog/cat/' data1.txtThe quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.$ sed -e '&gt; s/brown/green/&gt; s/dog/cat/&gt; ' data1.txtThe quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat. 注意使用分号时在命令末尾和分号之间不能有空格。如果使用多行模式必须在封尾单引号所在行结束命令。 从文件读取编辑器命令如果有大量要处理的sed命令，可以使用-f选项从文件中读取。 12345678$ cat script1.seds/brown/green/s/dog/cat/$ sed -f script1.sed data1.txtThe quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat. sed编辑器基础更多的替换选项 替换标记。上面使用的默认形式s/dog/cat/这种形式默认只会替换每行的第一个出现的dog。事实上，要让替换命令能够替换一行中不同地方出现的文本必须使用替换标记。替换标记会在替换命令字符串之后设置。 1s/pattern/replacement/flags 有四种可用的替换标记 数字，表明新文本将替换第几次模式匹配的地方。 g，表明新文本会替换所有的匹配文本。 p，表明原先行的内容要打印出来。 w file，将替换的结果写到文件中。 123456789101112131415$ cat data4.txtThis is a test of the test scriptThis is the second test of the test script$ sed 's/test/trail/2' data4.txtThis is a test of the trail scriptThis is the second test of the trail script$ sed 's/test/trail/g' data4.txtThis is a trail of the trail scriptThis is the second trail of the trail script$ sed 's/test/trail/gw temp' data4.txtThis is a trail of the trail scriptThis is the second trail of the trail script$ cat tempThis is a trail of the trail scriptThis is the second trail of the trail script p替换标记会输出修改过的行，一般和sed的-n选项一起使用。注意sed编辑器的正常输出在STDOUT中，只有那些包含匹配模式的行才会被w替换选项保存。 替换字符。替换文件中的路径名可能会非常麻烦。例如 1$ sed 's/\\/bin\\/bash/\\/bin\\/csh/' /etc/passwd 要解决这个问题，sed编辑器允许选择其他字符来作为替换命令的字符串分隔符 1$ sed 's!/bin/bash!/bin/csh!' /etc/passwd 使用地址 默认情况下，sed会处理所有行。如果只想命令作用于特定行或某些行，则必须使用行寻址。有两种行寻址方式。两种形式都使用相同的格式来指定地址。 1234567[address]commandaddress { command1 command2 ...} 以数字形式表示行区间。 用单个行号指定一行。 123456$ sed '2s/dog/cat/' data1.txtThe quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy cat.The quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy dog.$ 使用行号区间，起始行号+逗号+结束行号。 1234567891011$ sed '1,3s/dog/cat/' data1.txtThe quick brown fox jumps over the lazy cat.The quick brown fox jumps over the lazy cat.The quick brown fox jumps over the lazy cat.The quick brown fox jumps over the lazy dog.$ sed '2,$s/dog/cat/' data1.txtThe quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy cat.The quick brown fox jumps over the lazy cat.The quick brown fox jumps over the lazy cat.$ 注意这里可可用使用$来代表最后一行。 用文本模式过滤。sed编辑器允许指定文本模式来过滤出命令要作用的行。格式如下： 1/pattern/command 这里必须使用正斜线把pattern包裹起来。 12345$ sed '/quick/{s/dog/cat/; s/fox/tiger/}' data1.txtThe quick brown tiger jumps over the lazy cat.The quick brown tiger jumps over the lazy cat.The quick brown tiger jumps over the lazy cat.The quick brown tiger jumps over the lazy cat. 这里的pattern都是采用正则表达式匹配的。 同时这种方式也可用使用区间模式。 1/pattern1/,/pattern2/command 这种情况下会先找到pattern1作为开始模式，找到后对于后面紧跟的所有行都执行命令command，直到遇到pattern2命令结束，特别需要小心的一点是可能有多个区间被匹配到，造成不可知的结果，尽量少用。 命令组合。下面是一个组合命令 12345$ sed '/quick/{s/dog/cat/; s/fox/tiger/};2,3{s/cat/dog/;s/jump/run/}' data1.txtThe quick brown tiger jumps over the lazy cat.The quick brown tiger runs over the lazy dog.The quick brown tiger runs over the lazy dog.The quick brown tiger jumps over the lazy cat. 删除行 删除命令d它常常和上面的行寻址配合起来使用。例如 123456789$ cat data6.txtThis is line number 1.This is line number 2.This is line number 3.This is line number 4.$ sed '3d' data6.txtThis is line number 1.This is line number 2.This is line number 4. 插入和附加文本sed有两个插入操作。 i命令会在指定行前增加一个新行。 a命令会在指定行后增加一个新行。 格式如下： 12sed '[address]command\\new line' 下面是一个例子。 1234567891011$ sed '3a\\&gt; insert1&gt; 4i\\&gt; intert2' data6.txtThis is line number 1.This is line number 2.This is line number 3.insert1intert2This is line number 4.$ 从这个例子可以发现插入的语句是不会进入行计算里面的。（因为这里的This is line number 4.一直被当作第4行） 修改行sed中使用c命令来对行进行修改。格式和上面的插入相似，需要单独指定新行。 1234567$ sed '3c\\&gt; New Line' data6.txtThis is line number 1.This is line number 2.New LineThis is line number 4.$ 注意对于修改行命令我们也可以使用行区间的模式，但是c命令会把所有行替换为一行。 12345$ sed '2,$c\\&gt; New Line' data6.txtThis is line number 1.New Line$ 转换命令转换命令y是唯一可以处理单个字符的sed编辑器命令。格式如下 1[address]y/inchars/outchars/ y会对inchars和outchars进行一一映射，注意inchars和outchars长度需要相等。下面是一个例子 123456$ sed 'y/123/789/' data6.txtThis is line number 7.This is line number 8.This is line number 9.This is line number 4.$ 打印有三个命令能够用来打印数据流中的信息： p命令用来打印文本行。p命令一般和-n选项组合，配合行寻址。例子如下 1234$ sed -n '/3/{p;s/line/test/p}' data6.txtThis is line number 3.This is test number 3.$ =命令来打印行号。等号命令会打印行在数据流中的当前行号。例子如下 1234567891011121314$ sed -n '3{=;p;s/line/test/p}' data6.txt3This is line number 3.This is test number 3.$ sed '=' data6.txt1This is line number 1.2This is line number 2.3This is line number 3.4This is line number 4.$ l命令用来列出行。l命令可以打印数据流中不可打印的ASCII字符。任何不可打印字符要么在其八进制前加一个反斜线，要么使用C分格命名法（例如\\t）。 sed处理文件 写入文件。使用w命令可以写入文件。格式如下 1[address]w filename 将对应的行写入到文件中。 读取文件。r命令允许将一个独立文件的数据插入到数据流中。格式如下 1[address]r filename 这个命令如果不加地址会把r命令指定的文件内容插入到数据流的每一行后。例子如下 12345678910$ sed '/1/r data1.txt' data6.txtThis is line number 1.The quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy dog.This is line number 2.This is line number 3.This is line number 4.$ gawk 程序 虽然sed编辑器时非常方便自动修改文本文件的工具，但也有自身的限制。gawk能提供一个类编程环境来修改和重新组织文件中的数据。gawk提供了一种编程语言，可以做如下的事： 定义变量来保存数据。 使用算术和字符串操作来处理数据。 使用结构化编程（例如if-then语句和循环）。 通过提取数据文件中的数据元素，将其重新排序或格式化，生成格式化报告。 gawk程序的报告生成能力通常用来从大文件文本中提取数据元素，并将它们格式化成可读的报告。其中最完美的例子是格式化日志文件。 gawk简单应用gawk命令格式gawk程序的基本格式如下： 1gawk options program file 下面是gawk程序的一些可用选项 -F fs。指定行中划分数据字段的分段分隔符。 -f file。从指定文件中读取程序。 -v var=value。定义gawk程序中的一个变量及其默认值。 -mf N。指定要处理的数据文件中的最大字段数。 -mr N。指定数据文件中的最大数据行数。 -W keyword。指定gawk的兼容模式或警告等级。 gawk的强大之处在于程序脚本。可以写脚本来读取文本行的数据，然后处理并显示数据，创建任何类型的输出报告。 从命令行读取程序脚本gawk程序脚本用一对花括号来定义。必须将脚本命令放到两个花括号中。由于gawk命令行假定脚本是单个文本字符串，必须将脚本放到单引号中。下面是一个例子 1$ gawk '{print &quot;Hello World!&quot;}' 上面的例子使用了print命令，它会打印输出到STDOUT中，但是因为上面的命令没有指定文件，它会从STDIN读取输入。在运行的过程中它会一直等待STDIN的输入文本。如果输入一行文本然后按下回车键，gawk就会运行指定的脚本，在这个例子中就是打印一行Hello World!。 使用数据字段变量gawk会自动给一行中的每个数据元素分配一个变量。默认情况下，gawk会将如下变量分配给它在文本行中发现的数据字段。 $0代表整个文本行 $1代表文本行中的第一个数据字段 $n代表文本行中的第n个数据字段 在文本行中，每个数据字段都是通过字段分隔符划分的。gawk在读取一行文本时会用预定的字段分隔符划分每个数据字段。默认的时任意的空白字符。下面是一个例子 123456789101112131415161718192021$ cat data2.txtOne line of test text.Tow line of test text.Three line of test text.$ gawk '{print $1}' data2.txtOneTowThree$ gawk -F: '{print $1}' /etc/passwdrootdaemonbinsyssyncgamesmanlpmailnewsuucp[...] 在程序脚本中使用多个命令和sed类似，可以使用加分号和多行两种方式。 123456$ echo &quot;My name is Rich&quot; | gawk '{$4=&quot;Christine&quot;; print $0}'My name is Christine$ echo &quot;My name is Rich&quot; | gawk '{&gt; $4=&quot;Christine&quot;&gt; print $0}'My name is Christine 从文件中读取程序使用-f命令就可以指定文件。下面是一个例子 1234567891011121314$ cat script3.gawk{test = &quot;'s home directory is &quot;print $1 test $6}$ gawk -F: -f script3.gawk /etc/passwdroot's home directory is /rootdaemon's home directory is /usr/sbinbin's home directory is /binsys's home directory is /devsync's home directory is /bingames's home directory is /usr/games[...]$ 这里需要注意gawk程序在引用变量值时并未像shell脚本一样使用美元符。 在处理数据前后运行脚本可以使用BEGIN关键字和END关键字来分别定义在数据处理前后的行为。下面时一个例子 1234567891011121314151617181920212223242526$ cat script4.gawkBEGIN {print &quot;The latest list of users and shells&quot;print &quot; UserID \\t Shell&quot;print &quot;------- \\t ---------&quot;FS=&quot;:&quot;}{print $1 &quot; \\t &quot; $7}END {print &quot;This concludes the listing&quot;}$ gawk -f script4.gawk /etc/passwdThe latest list of users and shells UserID Shell------- ---------root /bin/bashdaemon /usr/sbin/nologinbin /usr/sbin/nologinsys /usr/sbin/nologinsync /bin/syncgames /usr/sbin/nologin$ 正则表达式正则表达式类型在linux中，有两种流行的正则表达式引擎： POSIX基础正则表达式（BRE）引擎 POSIX扩展正则表达式（ERE）引擎 sed编辑器只符合BRE引擎规范的子集，gawk程序用ERE引擎来处理它的正则表达式。 定义BRE模式纯文本简单的文本匹配，不包含特殊字符。 特殊字符正则表达式识别的特殊字符包括.*[]^${}\\+?|()。如果需要以纯文本模式匹配这些字符，需要使用\\进行转义。例如 123$ echo &quot;The cost is \\$4.00&quot; | sed -n '/\\$/p'The cost is $4.00$ 最后，尽管/不是一个特殊字符，但是在sed和gawk中使用时仍然需要转义。 123$ echo &quot;3 / 2&quot; | sed -n '/\\//p'3 / 2$ 锚字符 锁定在行首。^定义从数据流中文本行的行首开始的模式，会在每个由换行符决定的新数据行的行首检查模式。如果将^放到模式开头之外的其他位置，那它就跟普通字符一样，不再是特殊字符。 12345678$ echo &quot;sdas ^&quot; | sed -n '/^/p'sdas ^$ echo &quot;sdas ^&quot; | sed -n '/s ^/p'sdas ^$ echo &quot;sdas ^&quot; | sed -n '/^s/p'sdas ^$ echo &quot;sdas ^&quot; | sed -n '/^a/p'$ 锁定在行尾。$定义从数据流中文本行的行首开始的模式。和^完全类似。 组合使用。如果^和$组合使用，表示匹配只包含中间内容的行，特别的^$可以用来匹配空行。 点号字符.用来匹配除了换行符之外的任意单个字符。它必须匹配一个字符。 1234$ echo &quot;at&quot; | sed -n '/.at/p'$ echo &quot; at&quot; | sed -n '/.at/p' at$ 字符组使用方括号[]来定义一个字符组。方括号中包含所有希望出现在改字符组中的字符。 123$ echo &quot;Yes&quot; | sed -n '/[Yy][Ee][Ss]/p'Yes$ 排除型字符组在字符组的开头加上^可以反转字符组，去匹配没有在字符组中出现的字符。 12345$ echo &quot;hat&quot; | sed -n '/[^ch]at/p'$ echo &quot;at&quot; | sed -n '/[^ch]at/p'$ echo &quot; at&quot; | sed -n '/[^ch]at/p' at$ 区间可以使用单破折线符号-在字符组中表示字符。例如[1-9][a-g][a-ch-m]。 特殊字符组 组 描述 [[:alpha:]] a-z,A-Z [[:alnum:]] 0-9,a-z,A-Z [[:blank:]] 空格或者制表符 [[:digit:]] 0-9 [[:lower:]] a-z [[:upper:]] A-Z [[:print:]] 任意可打印字符 [[:punct:]] 标点符号 [[:space:]] 任意空白字符 星号在字符后面放置型号*表明该字符必须在匹配模式的文本中出现0次或者多次（注意这里和通配符*是不同的，不能混淆） 1234$ echo &quot;ik&quot; | sed -n '/ie*k/p'ik$ echo &quot;ieeeeek&quot; | sed -n '/ie*k/p'ieeeeek 扩展正则表达式注意这里属于ERE的范畴，也就是说sed不支持，gawk支持。 问号?表明前面出现的字符可以出现0次或者1次 123$ echo &quot;bt&quot; | gawk '/be?t/{print $0}'bt$ 加号+表示前面的字符出现1次或者多次 1234$ echo &quot;bt&quot; | gawk '/be+t/{print $0}'$ echo &quot;bet&quot; | gawk '/be+t/{print $0}'bet$ 使用花括号花括号允许为可重复的正则表达式指定一个上限。有两种形式 {m}。表示准确出现m次。 {m,n}。表示至少出现m次，至多出现n次。 注意gawk程序默认不识别。必须指定--re-interval。 1234$ echo &quot;bt&quot; | gawk --re-interval '/be{1}t/{print $0}'$ echo &quot;bet&quot; | gawk --re-interval '/be{1}t/{print $0}'bet$ 管道符号管道符号|相当于逻辑OR，只要两边的模式有一个匹配即可。 123456$ echo &quot;I'm a dog&quot; | gawk '/dog|cat/{print $0}'I'm a dog$ echo &quot;I'm a cat&quot; | gawk '/dog|cat/{print $0}'I'm a cat$ echo &quot;I'm a bird&quot; | gawk '/dog|cat/{print $0}'$ 表达式分组可以使用圆括号()进行分组。当使用分组时，该组合被当作一个字符，可以使用?+等特殊字符。 12345$ echo &quot;Saturday&quot; | gawk '/Sat(urday)?/{print $0}'Saturday$ echo &quot;Sat&quot; | gawk '/Sat(urday)?/{print $0}'Sat$","link":"/2021/01/19/sed,gawk%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"shell programming","slug":"shell-programming","link":"/tags/shell-programming/"},{"name":"linux command line","slug":"linux-command-line","link":"/tags/linux-command-line/"}],"categories":[{"name":"programming language","slug":"programming-language","link":"/categories/programming-language/"},{"name":"linux command line","slug":"linux-command-line","link":"/categories/linux-command-line/"}]}