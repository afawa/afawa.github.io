{"pages":[{"title":"About me","text":"简历测试","link":"/about/index.html"}],"posts":[{"title":"shell脚本构建","text":"构建基本shell脚本显示输出，引用变量 echo 命令，使用””和‘’进行区分 echo -n 随后的输出不会换行 $name，${name} 引用变量 ，使用\\$进行转义 命令替换 两种方法，反引号`和$( )格式 命令替换会创建一个子shell来运行对应的命令，所以无法使用在脚本中所创建的变量 在命令提示符下使用路径./运行命令的话，也会创建出子shell，要是运行命令的时候不加入路径，就不会创建子shell。如果使用的是shell内建命令，不会涉及子shell 重定向 &gt;&gt; 重定向输出并且不会清空文件原有的内容 内联输入重定向符号 &lt;&lt;，除了这个符号，你必须指定一个文本标记来划分输入数据的开始和结尾 12345$ wc &lt;&lt; EOF&gt; test string 1&gt; test string 2&gt; test string 3&gt; EOF 执行数学运算 第一种方式使用expr命令，例如expr 1 + 5，expr 2 \\* 5，在shell中使用需要进行命令替换 第二种方式使用方括号，例如 var=$[1 + 5]，var=$[2 * 5] bash shell 原生只支持整形运算 在bash中使用浮点运算的一种方式是使用内建计算器bc，在脚本中使用bc，可以使用命令替换+管道的方式，例如 123var1=100var2=45var=$(echo &quot;scale=4; $var1 / $var2&quot; | bc) 或者使用内联输入重定向，例如 1234567var=$( bc &lt;&lt; EOFscale=4a1 = ($var1 * $var2)b1 = ($var3 * $var4)a1 + b1EOF) 退出脚本 linux提供了专门的变量$?来存储上一个命令的退出状态码，可以直接用echo $?查看 默认情况下shell脚本会以脚本的最后一个命令的退出码退出 可以使用exit命令指定退出码 退出码范围 0~255","link":"/2021/01/08/shell%E8%84%9A%E6%9C%AC%E6%9E%84%E5%BB%BA/"},{"title":"shell脚本结构化命令","text":"结构化命令if-then 语句1234if commandthen commandsfi 如果if后的命令的推出码是0，则会运行then部分。 运行if语句中的错误信息依然会显示，可以用某些方法避免 另一种形式 123if command; then commandsfi if-then-else 语句 123456if commandthen commandselse commandsfi if中的语句的退出码不为0时，运行else中的语句 嵌套if123456if command1then commandselif command2 commandsfi test 命令如果test命令中列出的条件成立，test命令就会退出并返回退出码0。如果condition部分本身为空，那么test以非零返回。 1234567# test 命令test condition# test 命令结合if-elseif test conditionthen commandsfi bash 提供了另一种测试方式，不需要声明test命令。方括号定义了测试条件，第一个方括号后和第二个方括号前必须加上一个空格。 1234if [ condition ]then commandsfi test可以测试一个变量是否为空，不为空则返回0 数值比较 n1 arg n2，其中n1，n2是数值，arg是选项，arg包括 -eq, -ge, -gt, -le, -lt, -ne （相等，大于等于，大于，小于等于，小于，不等于）。 bash shell只能处理整数，test命令不能处理浮点数。 字符串比较 字符串相等性。str1 = str2 判断两个字符串是否相等，str1 != str2 判断两个字符串是否不相等 字符串顺序。str1 \\&gt; str2 , str1 \\&lt; str2。大于号小于号必须使用转义，不然会被理解成重定向符号。在test中，根据ASCII标准进行排序，sort和test对于大写小写的判断是反的。 字符串大小。-n str1 检查str1的长度是否为0 ，-z str1 检查str1的长度是否不为0。 文件比较 检查目录。-d file，检查file是否存在并是一个目录。 检查对象是否存在。-e file，检查file是否存在。 检查文件。-f file，检查file是否存在并是一个文件。 检查是否可读。-r file，检查file是否存在并可读。 检查空文件。-s file，检查file是否存在并非空。 检查是否可写。-w file，检查file是否存在并可写。 检查文件是否可以执行。-x file，检查file是否存在并可执行。 检查所属关系。-O file，检查file是否存在并属于当前用户所有。 检查默认属主关系。-G file，检查file是否存在并且默认组与当前用户相同。 检查文件日期。file1 -nt file2，检查file1是否比file2新。file1 -ot file2，检查file1是否比file2旧。 复合条件测试 允许使用 &amp;&amp; 和 || 连接多个condition。 if-then 高级特性 双括号。双括号命令运行在比较过程中使用高级数学符号。（几乎是所有c中的运算都能用）并且在双括号中不需要对&gt;和&lt;进行转义。 12345var=10if (( var ** 2 &lt; 1000 ))then var=$(( var-- ))fi 双方括号。双方括号中可以使用模式匹配。例如 [[ $USER == r* ]]，这里使用了==，右边的r*就是一个模式。 case 命令类似switch命令，格式如下 12345case variable inpattern1 | pattern2) commands1;;pattern3) commands2;;*) commands3;;esac for 命令1234for var in listdo commandsdone 在list参数中，需要提供迭代中要用到的一系列值。 读取列表中的值。for命令最基本的用法就是遍历for命令本身所定义的一系列值。在最后一次迭代后，$test的值会在shell脚本的剩余部分一直保持有效。 1234for test in aaa bbb ccc ddddo echo $testdone 读取列表中的复杂值。 如果列表中的值存在单引号，可以用如下两种方式：1.使用转义，2.使用双引号。 1234for test in I don\\'t know if &quot;this'll&quot; workdo echo $testdone 如果存在空格，必须使用双引号把这个值框起来。 从变量读取列表 123456list=&quot;aaa bbb ccc&quot;list=$list&quot; ddd&quot;for test in listdo echo $testdone 从命令读取值 12345file=testfile.txtfor test in $(cat $file)do echo $testdone 更改字段分隔符 内部字段分隔符，IFS环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字符当作字段分隔符：1. 空格，2. 制表符，3. 换行符 修改IFS，例如，IFS=$'\\n'。这里注意用$'\\n'，$'string'是用来表示带转义序列的字符串文字的语法 (called ANSI C-quoted strings) 指定多个的时候只需要简单拼接。IFS=$'\\n':;&quot; 用通配符读取目录 必须使用通配符，它会强制shell使用文件扩展匹配。 1234567for file in /home/yiming/*do if [ -d &quot;$file&quot; ] then echo &quot;$file is a directory&quot; fidone 注意这里”$file”应对文件名带空格的情况。同时可以使用多个通配符拼接，通配符加目录一起使用 C风格for1for (( variable assignment ; condition ; iteration process )) 变量赋值可以用空格 条件中的变量不已美元开头 迭代过程的算式不使用expr表达式 123456789for (( i=1 ; i&lt;=10 ; i++ ))do echo $idonefor (( a=1, b=10; a&lt;=10; a++, b-- ))do echo &quot;$a - $b&quot;done while 命令 基本格式 1234while test commanddo other commanddone 这里的test command和if-else语句一模一样。 12345var1=10while [ $var -gt 1 ]do var1=$(( var - 1 ))done 使用多个测试命令 while 命令允许你在while语句定义多个测试命令，只有最后一个测试命令的退出状态码会被用来决定什么时候退出循环。 123456var1=10while echo $var1 [ $var1 -ge 0 ]do var=$(( var1 - 1 ))done until 命令 1234until test commandsdo other commandsdone 本质是和while相反的语句。 循环控制 break命令。直接使用break命令会跳出当前正在执行的循环。可以使用 break n来指定跳出的层数，默认n=1也就是跳出当前循环。 continue命令。和break相同，可以使用continue n的语法指定继续执行哪一级的循环。 处理循环的输出在shell脚本中可以对循环的输出使用管道或进行重定向。可以通过在done命令后添加一个处理命令来实现。 12345678910111213141516171819# 重定向例子for (( a=1; a&lt;=10; a++))do echo $adone &gt; output.txt# 也可以使用重定向进行输入，然后用read命令处理input=&quot;users.csv&quot;while IFS=',' read -r userid namedo echo &quot;adding $userid&quot; useradd -c &quot;$name&quot; -m $useriddone &lt; &quot;$input&quot;# 管道例子for (( a=1; a&lt;=10; a++))do echo $adone | sort","link":"/2021/01/08/shell%E8%84%9A%E6%9C%AC%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4/"},{"title":"shell输入输出处理","text":"shell 处理输入输出处理用户输入命令行参数 读取参数。 bash shell会将一些称为位置参数的特殊变量分配给输入到命令行中的所有参数。位置参数是标准的数字：$0是程序名，$1是第一个参数，一直到$9。如果参数不止9个，需要使用${10}这种方式使用参数。 如果参数值中包含空格，需要使用引号来（单引号或者双引号），将文本字符串作为参数传递时，引号并非数据的一部分，只是表明数据的起止位置。 1$ ./test.sh &quot;Rich Blum&quot; 读取脚本名。可以使用$0获取shell在命令行启动的脚本名。但是这里存在一个问题，如果使用另一个命令来运行shell脚本，命令会和脚本名混在一起，出现在$0参数中。并且如果使用脚本完整路径使用脚本时，会显示脚本的绝对路径。为了只使用脚本的名称，可以使用basename命令。 1name=$(basename $0) 测试参数。需要在使用之前检查是否传入了对应量的参数。下面是一个例子。 123456if [ -n &quot;$1&quot; ]then echo $1else echo &quot;not define&quot;fi 特殊参数变量 参数统计。$#变量中存储了脚本运行时携带的命令行参数的个数。如果想要之间使用最后一个参数，可以使用${!#}来引用。 抓取所有数据。$@和$*可以用来对于参数进行遍历。 $*变量会将命令行上提供的所有参数保存为一个单词。 $@变量会将命令行上提供的所有参数当作同一个字符串中的多个独立的单词。（用于遍历十分方便） 移动变量 shift 命令可以用来操作命令行参数，默认情况下它会将每个参数向左移动一个位置，$3 -&gt; $2 并且原来的$1直接消失，$0内依然是脚本名。当不知道有多少参数时，可以用它配合while进行遍历。例子如下 12345while [ -n &quot;$1&quot; ]do echo $1 shiftdone 同时也可以对于shift指定一个数字，代表移动的数量，shift 2就是移动两个变量。 处理选项 查找选项 处理简单选项。可以使用case语句配合shift进行选项提取。例如 123456789while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found -a&quot; ;; -b) echo &quot;Found -b&quot; ;; *) echo &quot;$1 is not a option&quot; ;; esac shiftdone 分离参数和选项。如果在脚本中同时使用选项和参数，Linux中处理这个问题的标准方式是用特殊字符将两者分开。对Linux来说，这个特殊字符是--。shell会用--来表明选项列表的结束，之后的都会被当作命令行参数。实现时只需要在case语句中加入对于--的判断。 12345678910111213141516 while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found -a&quot; ;; -b) echo &quot;Found -b&quot; ;; --) shift break ;; *) echo &quot;$1 is not a option&quot; ;; esac shift done for para in $@ do echo &quot;Parameter $para&quot; done 处理带值的选项。例子如下 1234567891011121314151617while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found -a&quot; ;; -b) para=&quot;$2&quot; echo &quot;Found -b, parameter=$para&quot; shift ;; --) shift break ;; *) echo &quot;$1 is not a option&quot; ;; esac shiftdonefor para in $@do echo &quot;Parameter $para&quot;done 这里-b选项需要一个额外的参数。 使用getopt命令。上面的内容无法处理更加复杂的需求，例如我们想要把多个选项放到一个参数中 1$ ./test.sh -ac 这样的操作需要使用getopt选项 getopt格式。getopt optstring parameters，其中optstring定义了有效的选项字母，还定义了哪些选项需要参数值。在optstring中列出每个需要参数值的字母，然后再每个需要参数值的选项字母后加一个冒号。getopt会根据optstring进行解析。例子如下 123$ getopt ab:cd -a -b test1 -cd test2 test3-a -b test1 -c -d -- test2 test3$ 如果指定了一个不在optstring中的选项，默认情况下会产生一条错误信息， 1234$ getopt ab:cd -a -b test1 -cde test2 test3getopt: invalid option -- 'e'-a -b test1 -c -d -- test2 test3$ 可以在命令后加入-q选项 123$ getopt -q ab:cd -a -b test1 -cde test2 test3-a -b test1 -c -d -- test2 test3$ 在脚本中使用getopt。方法是使用getopt命令生成的格式化后的版本来替换已有的命令行选项和参数。需要使用set命令。set命令的选项之一是--，它会将命令行参数替换为set命令的命令行值。 12345678910111213141516171819202122#!/bin/bashset -- $(getopt -q ab:cd &quot;$@&quot;)while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found -a&quot; ;; -b) para=&quot;$2&quot; echo &quot;Found -b, parameter=$para&quot; shift ;; -c) echo &quot;Found -c&quot; ;; -d) echo &quot;Found -d&quot; ;; --) shift break ;; *) echo &quot;$1 is not a option&quot; ;; esac shiftdonefor para in $@do echo &quot;Parameter $para&quot;done 但是getopt任然存在一个小问题：getopt并不擅长处理带引号和空格的场景，对于上述代码，下面的方法可以解决这个问题。 12345678$ ./test.sh -a -b test1 -cd &quot;test2 test3&quot; test4Found -aFound -b, parameter=test1Found -cFound -dParameter 'test2Parameter test3'parameter 'test4' getopts命令。与getopt不同，前者将命令行上选项和参数处理后只生成一个输出，而getopts命令能够和已有的shell参数变量配合。每次调用它时，它一次处理命令行上检测的一个参数。处理完所有参数后，它会退出并返回一个大于0的退出码。可以和循环命令结合使用。命令格式如下： 1getopts optstring variable 其中optstring和getopt命令类似，注意如果需要去掉错误信息的话，可以在optstring之前加一个冒号。getopts命令将当前参数保存在命令行中定义的variable中。getopts命令会用到两个环境变量，如果选项需要跟一个参数值，OPTARG环境变量就会保存这个值。OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。 12345678910#!/bin/bashwhile getopts :ab:c optdo case &quot;$opt&quot; in a) echo &quot;Found -a&quot; ;; b) echo &quot;Found -b, parameter $OPTARG&quot; ;; c) echo &quot;Found -c&quot; ;; *) echo &quot;Unknown option $opt&quot; ;; esacdone 注意对于$OPTARG如果包含空格需要用引号包裹。 1234$ ./test.sh -ab &quot;test1 test2&quot; -cFound -aFound -b, parameter test1 test2Found -c 初次之外，getopts将命令行上找到的所有未定义的选项统一输出为问号。 12345$ ./test.sh -ab &quot;test1 test2&quot; -c -dFound -aFound -b, parameter test1 test2Found -cUnknown option ? getopts只会处理选项参数，可以使用shift结合OPTIND环境变量来解析后续参数。 1234567891011121314151617#!/bin/bashwhile getopts :ab:c optdo case &quot;$opt&quot; in a) echo &quot;Found -a&quot; ;; b) echo &quot;Found -b, parameter $OPTARG&quot; ;; c) echo &quot;Found -c&quot; ;; *) echo &quot;Unknown option $opt&quot; ;; esacdoneshift $[ $OPTIND - 1 ]for para in &quot;$@&quot;do echo &quot;Parameter $para&quot;done 这样就可以处理了， 12345678910111213$ ./test.sh -ab &quot;test1 test2&quot; -c test3 test4Found -aFound -b, parameter test1 test2Found -cParameter test3Parameter test4$ ./test.sh -ab test1 test2 -c test3 test4Found -aFound -b, parameter test1Parameter test2Parameter -cParameter test3Parameter test4 不过需要注意getopts解析时需要把选项放在参数之前，这点和getopt不一样，对于getopt或默认把参数整理出来放在最后。 12$ getopt ab:c -ab test1 test2 -c test3 test4 -a -b test1 -c -- test2 test3 test4 读取用户输入 基本的读取。read命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后read命令会将数据存在一个变量里。 12read nameecho &quot;I'm $name&quot; read命令包含了-p选项能够在命令行指定提示符 12read -p &quot;Who are you?&quot; nameecho &quot;I'm $name&quot; read可以指定多个变量，输入的每个数值都会分配给变量列表中的下一个变量，如果变量数量不够，剩下的数据就全部分配给最后一个变量。read也可以不指定变量，这样的话收到的任何数据都会在特殊环境变量REPLY中。 超时，限定数目。 -t选项指定了read命令等待输入的秒数，当计时器过期之后，read命令返回一个非零退出码。 也可以不对输入过程计时，而是让read命令来统计输入的字符数。使用-n选项加上一个数字代表接受多少个字符。 隐藏输入。使用-s命令避免read命令中输入的数据出现在显示器上。 从文件中读取。每次使用read都会读取文件的一行，直到文件末尾，使用方式就是 cat + 管道 + while + read 。（done + 重定向也是可以的） 123456count=1cat test.txt | while read linedo echo &quot;$count $line&quot; count=$[ $count + 1 ]done 呈现数据输入和输出 标准文件描述符。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符。bash shell保留了前三个文件描述符。 0 STDIN 标准输入。 1 STDOUT 标准输出。当命令生成错误信息时，shell创建了输出重定向文件，但错误信息显示在显示屏上。如果使用输出重定向，此时错误信息不会出现在重定向的文件中。 2 STDERR 标准错误。默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给他们的文件描述符不同）。也就是说在默认情况下，错误信息也会显示在显示器上。但是STDERR不会随着STDOUT的重定向而发生改变。 重定向错误。 只重定向错误。可以选择只重定向错误信息，讲该文件描述符值放在重定向符号前（必须紧跟） 1$ ls -al badfile 2&gt; test 这样的话只会把错误进行重定向，标准输出还是会出现在屏幕上。 重定向错误和数据。 如果想要将两者标准输出和错误输出分开重定向。使用如下形式 1$ls -al goodfile badfile 1&gt; test1 2&gt; test2 如果想要将两者输出一起重定向，使用&amp;&gt;符号 1$ls -al goodfile badfile &amp;&gt; test 使用&amp;&gt;符号时，为了避免错误信息散落在输出文件中，相较于标准输出，bash shell自动赋予了错误信息更高的优先级，重定向后所有的错误信息会集中在开头。 脚本中重定向输出 临时重定向。如果有意在脚本中生成错误信息，可以将单独的一行输出重定向到STDERR。 1echo &quot;error message&quot; &gt;&amp;2 这行把echo命令的输出重定向到STDERR中。 永久重定向。可以使用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符。 12345exec 2&gt;errorfileecho &quot;normal message&quot;exec 1&gt;outputfileecho &quot;in output file&quot;echo &quot;in error file&quot; &gt;&amp;2 脚本中重定向输入 可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。exec命令允许你将STDIN重定向到Linux系统上的文件。 1exec 0&lt; testfile 创建自己的重定向 创建输出文件描述符。可以使用exec命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件描述符分配给一个文件，这个重定向就会一直有效，直到重新分配。 12exec 3&gt;testfileecho &quot;test message&quot; &gt;&amp;3 重定向文件描述符。你可以分配另外一个描述符给标准文件描述符，反之亦然。可以使用这个方法恢复以重定向的文件描述符。 1234exec 3&gt;&amp;1exec 1&gt;testfileecho &quot;In file&quot;exec 1&gt;&amp;3 上面这个例子先把3重定向到1的当前位置，然后把1重定向到testfile文件，现在echo命令的输出会出现在文件中，然后再把1重定向到3的位置，也就是恢复了原来的STDOUT。这是一种再脚本中临时重定向输出，然后恢复默认输出设置的常用方法。 创建输入文件描述符。相似的也可以临时重定向STDIN然后恢复 1234567exec 6&lt;&amp;0exec 0&lt;testfilewhile read linedo echo $linedoneexec 0&lt;&amp;6 创建读写描述符。由于是对同一个文件进行读写，shell会维护一个内部指针，指明在文件中的当前位置，任何读写都会从文件指针上次的位置开始。需要特别小心，可以看下面这个例子。 1234567891011121314151617$ cat test.sh#!/bin/bashexec 3&lt;&gt; testfileread line &lt;&amp;3echo &quot;Read: $line&quot;echo &quot;This is a test line&quot; &gt;&amp;3$ cat testfileThis is the first line.This is the second line.This is the third line.$ ./test.shReAD: This is the first line.$ cat testfileThis is the first line.This is a test lineine.This is the third line. 可以发现在对于testfile文件进行一次读取后，指针位于第二行的开头，这时写入的话会覆盖文件第二行的内容。 关闭文件描述符。如果创建了新的输入或输出文件描述符，shell会在脚本退出是自动关闭他们。如果需要手动关闭，将它重定向到特殊符号&amp;-。下面的这段代码允许会报错。 1234exec 3&gt;testfileecho &quot;test message&quot; &gt;&amp;3exec 3&gt;&amp;-echo &quot;bad message&quot; &gt;&amp;3 如果随后在脚本中打开了同一个输出文件，shell会用一个新文件替换已有文件。（需要用&gt;&gt;） 列出打开的文件描述符 lsof命令会列出整个linux系统打开的所有文件描述符。该命令会产生大量输出，会显示当前系统上打开的每个文件的有关信息。这包括后台运行的所有进程以及登录到系统的任何用户。有大量的参数可以过滤输出，-p运行输出PID，-d指定需要显示的文件描述符编号，-a用于对于多个选项的输出求交。 阻止命令输出 如果想要丢弃某些输出。例如丢弃STDERR的输出，可以将其重定向到/dev/null文件。重定向到该位置的任何数据都会被丢掉。 1ls -al badfile testfile 2&gt; /dev/null 这种方式可以丢弃报错信息。 创建临时文件linux系统有特殊的目录，专供临时文件使用。linux使用/tmp目录来存放不需要永久保存的文件。大多数linux发行版配置了系统在启动时自动删除/tmp目录的所有文件。系统上的任何用户都有权限在读写/tmp目录中的文件。 mktemp命令可以用来创建临时文件，可以在/tmp目录中创建一个唯一的临时文件。会将文件的读写权限分配给文件的属主，并将用户设置为文件的属主，其他人没法访问它。 创建本地临时文件。默认情况下mktemp会在本地创建一个文件。要用mktemp命令在本地目录中创建一个临时文件，只需要指定一个文件名模板就可以了。模板可以包含任意文本文件名，在文件名末尾加上6个x就行了。mktemp命令会用6个字符码替换这6个x，保证文件名在当前目录是唯一的。mktemp命令的输出是文件名（相对路径），在脚本中使用这个命令时，可能要将文件名保存在变量中，这样就可以继续引用了。 1234567tmpfile=$(mktemp test.xxxxxx)exec 3&gt;$tmpfileecho &quot;first line&quot; &gt;&amp;3exec 3&gt;&amp;-echo &quot;file contains:&quot;cat $tmpfilerm -f $tmpfile 2&gt; /dev/null 在/tmp目录创建临时文件。-t选项会强制mktemp命令在系统的临时目录来创建该文件，此时mktemp返回临时文件的绝对路径。 创建临时目录。-d选项告诉mktemp命令创建一个临时目录。可以在这个临时目录下继续创建临时文件。 1234tmpdir=$(mktemp -d dir.xxxxxx)cd $tmpdirtmpfile1=$(mktemp temp.xxxxxx)tmpfile2=$(mktemp temp.xxxxxx) 记录消息 如果想要输出同时出现在显示屏和日志文件上，可以使用tee命令。tee从STDIN读取的数据发向两端，一端是STDOUT，另一端是命令行指定的文件tee file。 1date | tee testfile 注意默认情况tee会覆盖输出文件，如果需要追加写入需要使用-a选项。","link":"/2021/01/17/shell%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/"}],"tags":[{"name":"shell programming","slug":"shell-programming","link":"/tags/shell-programming/"}],"categories":[{"name":"programming language","slug":"programming-language","link":"/categories/programming-language/"}]}