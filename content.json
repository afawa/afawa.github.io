{"pages":[{"title":"About me","text":"简历测试","link":"/about/index.html"}],"posts":[{"title":"shell脚本构建","text":"构建基本shell脚本显示输出，引用变量 echo 命令，使用””和‘’进行区分 echo -n 随后的输出不会换行 $name，${name} 引用变量 ，使用\\$进行转义 命令替换 两种方法，反引号`和$( )格式 命令替换会创建一个子shell来运行对应的命令，所以无法使用在脚本中所创建的变量 在命令提示符下使用路径./运行命令的话，也会创建出子shell，要是运行命令的时候不加入路径，就不会创建子shell。如果使用的是shell内建命令，不会涉及子shell 重定向 &gt;&gt; 重定向输出并且不会清空文件原有的内容 内联输入重定向符号 &lt;&lt;，除了这个符号，你必须指定一个文本标记来划分输入数据的开始和结尾 12345$ wc &lt;&lt; EOF&gt; test string 1&gt; test string 2&gt; test string 3&gt; EOF 执行数学运算 第一种方式使用expr命令，例如expr 1 + 5，expr 2 \\* 5，在shell中使用需要进行命令替换 第二种方式使用方括号，例如 var=$[1 + 5]，var=$[2 * 5] bash shell 原生只支持整形运算 在bash中使用浮点运算的一种方式是使用内建计算器bc，在脚本中使用bc，可以使用命令替换+管道的方式，例如 123var1=100var2=45var=$(echo &quot;scale=4; $var1 / $var2&quot; | bc) 或者使用内联输入重定向，例如 1234567var=$( bc &lt;&lt; EOFscale=4a1 = ($var1 * $var2)b1 = ($var3 * $var4)a1 + b1EOF) 退出脚本 linux提供了专门的变量$?来存储上一个命令的退出状态码，可以直接用echo $?查看 默认情况下shell脚本会以脚本的最后一个命令的退出码退出 可以使用exit命令指定退出码 退出码范围 0~255","link":"/2021/01/08/shell%E8%84%9A%E6%9C%AC%E6%9E%84%E5%BB%BA/"},{"title":"shell脚本结构化命令","text":"结构化命令if-then 语句1234if commandthen commandsfi 如果if后的命令的推出码是0，则会运行then部分。 运行if语句中的错误信息依然会显示，可以用某些方法避免 另一种形式 123if command; then commandsfi if-then-else 语句 123456if commandthen commandselse commandsfi if中的语句的退出码不为0时，运行else中的语句 嵌套if123456if command1then commandselif command2 commandsfi test 命令如果test命令中列出的条件成立，test命令就会退出并返回退出码0。如果condition部分本身为空，那么test以非零返回。 1234567# test 命令test condition# test 命令结合if-elseif test conditionthen commandsfi bash 提供了另一种测试方式，不需要声明test命令。方括号定义了测试条件，第一个方括号后和第二个方括号前必须加上一个空格。 1234if [ condition ]then commandsfi test可以测试一个变量是否为空，不为空则返回0 （True） 数值比较 n1 arg n2，其中n1，n2是数值，arg是选项，arg包括 -eq, -ge, -gt, -le, -lt, -ne （相等，大于等于，大于，小于等于，小于，不等于）。 bash shell只能处理整数，test命令不能处理浮点数。 字符串比较 字符串相等性。str1 = str2 判断两个字符串是否相等，str1 != str2 判断两个字符串是否不相等 字符串顺序。str1 \\&gt; str2 , str1 \\&lt; str2。大于号小于号必须使用转义，不然会被理解成重定向符号。在test中，根据ASCII标准进行排序，sort和test对于大写小写的判断是反的。 字符串大小。-n str1 检查str1的长度是否为0 ，-z str1 检查str1的长度是否不为0。 文件比较 检查目录。-d file，检查file是否存在并是一个目录。 检查对象是否存在。-e file，检查file是否存在。 检查文件。-f file，检查file是否存在并是一个文件。 检查是否可读。-r file，检查file是否存在并可读。 检查空文件。-s file，检查file是否存在并非空。 检查是否可写。-w file，检查file是否存在并可写。 检查文件是否可以执行。-x file，检查file是否存在并可执行。 检查所属关系。-O file，检查file是否存在并属于当前用户所有。 检查默认属主关系。-G file，检查file是否存在并且默认组与当前用户相同。 检查文件日期。file1 -nt file2，检查file1是否比file2新。file1 -ot file2，检查file1是否比file2旧。 表达式选项、操作 ! expression，对于某个表达式取非。 expression1 -a expression2，相当于AND操作，需要两边的表达式共同满足。 复合条件测试 允许使用 &amp;&amp; 和 || 连接多个condition。 if-then 高级特性 双括号。双括号命令运行在比较过程中使用高级数学符号。（几乎是所有c中的运算都能用）并且在双括号中不需要对&gt;和&lt;进行转义。 12345var=10if (( var ** 2 &lt; 1000 ))then var=$(( var-- ))fi 双方括号。双方括号中可以使用模式匹配。例如 [[ $USER == r* ]]，这里使用了==，右边的r*就是一个模式。 case 命令类似switch命令，格式如下 12345case variable inpattern1 | pattern2) commands1;;pattern3) commands2;;*) commands3;;esac for 命令1234for var in listdo commandsdone 在list参数中，需要提供迭代中要用到的一系列值。 读取列表中的值。for命令最基本的用法就是遍历for命令本身所定义的一系列值。在最后一次迭代后，$test的值会在shell脚本的剩余部分一直保持有效。 1234for test in aaa bbb ccc ddddo echo $testdone 读取列表中的复杂值。 如果列表中的值存在单引号，可以用如下两种方式：1.使用转义，2.使用双引号。 1234for test in I don\\'t know if &quot;this'll&quot; workdo echo $testdone 如果存在空格，必须使用双引号把这个值框起来。 从变量读取列表 123456list=&quot;aaa bbb ccc&quot;list=$list&quot; ddd&quot;for test in listdo echo $testdone 从命令读取值 12345file=testfile.txtfor test in $(cat $file)do echo $testdone 更改字段分隔符 内部字段分隔符，IFS环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字符当作字段分隔符：1. 空格，2. 制表符，3. 换行符 修改IFS，例如，IFS=$'\\n'。这里注意用$'\\n'，$'string'是用来表示带转义序列的字符串文字的语法 (called ANSI C-quoted strings) 指定多个的时候只需要简单拼接。IFS=$'\\n':;&quot; 用通配符读取目录 必须使用通配符，它会强制shell使用文件扩展匹配。 1234567for file in /home/yiming/*do if [ -d &quot;$file&quot; ] then echo &quot;$file is a directory&quot; fidone 注意这里”$file”应对文件名带空格的情况。同时可以使用多个通配符拼接，通配符加目录一起使用 C风格for1for (( variable assignment ; condition ; iteration process )) 变量赋值可以用空格 条件中的变量不已美元开头 迭代过程的算式不使用expr表达式 123456789for (( i=1 ; i&lt;=10 ; i++ ))do echo $idonefor (( a=1, b=10; a&lt;=10; a++, b-- ))do echo &quot;$a - $b&quot;done while 命令 基本格式 1234while test commanddo other commanddone 这里的test command和if-else语句一模一样。 12345var1=10while [ $var -gt 1 ]do var1=$(( var - 1 ))done 使用多个测试命令 while 命令允许你在while语句定义多个测试命令，只有最后一个测试命令的退出状态码会被用来决定什么时候退出循环。 123456var1=10while echo $var1 [ $var1 -ge 0 ]do var=$(( var1 - 1 ))done until 命令 1234until test commandsdo other commandsdone 本质是和while相反的语句。 循环控制 break命令。直接使用break命令会跳出当前正在执行的循环。可以使用 break n来指定跳出的层数，默认n=1也就是跳出当前循环。 continue命令。和break相同，可以使用continue n的语法指定继续执行哪一级的循环。 处理循环的输出在shell脚本中可以对循环的输出使用管道或进行重定向。可以通过在done命令后添加一个处理命令来实现。 12345678910111213141516171819# 重定向例子for (( a=1; a&lt;=10; a++))do echo $adone &gt; output.txt# 也可以使用重定向进行输入，然后用read命令处理input=&quot;users.csv&quot;while IFS=',' read -r userid namedo echo &quot;adding $userid&quot; useradd -c &quot;$name&quot; -m $useriddone &lt; &quot;$input&quot;# 管道例子for (( a=1; a&lt;=10; a++))do echo $adone | sort","link":"/2021/01/08/shell%E8%84%9A%E6%9C%AC%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4/"},{"title":"shell输入输出处理","text":"shell 处理输入输出处理用户输入命令行参数 读取参数。 bash shell会将一些称为位置参数的特殊变量分配给输入到命令行中的所有参数。位置参数是标准的数字：$0是程序名，$1是第一个参数，一直到$9。如果参数不止9个，需要使用${10}这种方式使用参数。 如果参数值中包含空格，需要使用引号来（单引号或者双引号），将文本字符串作为参数传递时，引号并非数据的一部分，只是表明数据的起止位置。 1$ ./test.sh &quot;Rich Blum&quot; 读取脚本名。可以使用$0获取shell在命令行启动的脚本名。但是这里存在一个问题，如果使用另一个命令来运行shell脚本，命令会和脚本名混在一起，出现在$0参数中。并且如果使用脚本完整路径使用脚本时，会显示脚本的绝对路径。为了只使用脚本的名称，可以使用basename命令。 1name=$(basename $0) 测试参数。需要在使用之前检查是否传入了对应量的参数。下面是一个例子。 123456if [ -n &quot;$1&quot; ]then echo $1else echo &quot;not define&quot;fi 特殊参数变量 参数统计。$#变量中存储了脚本运行时携带的命令行参数的个数。如果想要之间使用最后一个参数，可以使用${!#}来引用。 抓取所有数据。$@和$*可以用来对于参数进行遍历。 $*变量会将命令行上提供的所有参数保存为一个单词。 $@变量会将命令行上提供的所有参数当作同一个字符串中的多个独立的单词。（用于遍历十分方便） 移动变量 shift 命令可以用来操作命令行参数，默认情况下它会将每个参数向左移动一个位置，$3 -&gt; $2 并且原来的$1直接消失，$0内依然是脚本名。当不知道有多少参数时，可以用它配合while进行遍历。例子如下 12345while [ -n &quot;$1&quot; ]do echo $1 shiftdone 同时也可以对于shift指定一个数字，代表移动的数量，shift 2就是移动两个变量。 处理选项 查找选项 处理简单选项。可以使用case语句配合shift进行选项提取。例如 123456789while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found -a&quot; ;; -b) echo &quot;Found -b&quot; ;; *) echo &quot;$1 is not a option&quot; ;; esac shiftdone 分离参数和选项。如果在脚本中同时使用选项和参数，Linux中处理这个问题的标准方式是用特殊字符将两者分开。对Linux来说，这个特殊字符是--。shell会用--来表明选项列表的结束，之后的都会被当作命令行参数。实现时只需要在case语句中加入对于--的判断。 12345678910111213141516 while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found -a&quot; ;; -b) echo &quot;Found -b&quot; ;; --) shift break ;; *) echo &quot;$1 is not a option&quot; ;; esac shift done for para in $@ do echo &quot;Parameter $para&quot; done 处理带值的选项。例子如下 1234567891011121314151617while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found -a&quot; ;; -b) para=&quot;$2&quot; echo &quot;Found -b, parameter=$para&quot; shift ;; --) shift break ;; *) echo &quot;$1 is not a option&quot; ;; esac shiftdonefor para in $@do echo &quot;Parameter $para&quot;done 这里-b选项需要一个额外的参数。 使用getopt命令。上面的内容无法处理更加复杂的需求，例如我们想要把多个选项放到一个参数中 1$ ./test.sh -ac 这样的操作需要使用getopt选项 getopt格式。getopt optstring parameters，其中optstring定义了有效的选项字母，还定义了哪些选项需要参数值。在optstring中列出每个需要参数值的字母，然后再每个需要参数值的选项字母后加一个冒号。getopt会根据optstring进行解析。例子如下 123$ getopt ab:cd -a -b test1 -cd test2 test3-a -b test1 -c -d -- test2 test3$ 如果指定了一个不在optstring中的选项，默认情况下会产生一条错误信息， 1234$ getopt ab:cd -a -b test1 -cde test2 test3getopt: invalid option -- 'e'-a -b test1 -c -d -- test2 test3$ 可以在命令后加入-q选项 123$ getopt -q ab:cd -a -b test1 -cde test2 test3-a -b test1 -c -d -- test2 test3$ 在脚本中使用getopt。方法是使用getopt命令生成的格式化后的版本来替换已有的命令行选项和参数。需要使用set命令。set命令的选项之一是--，它会将命令行参数替换为set命令的命令行值。 12345678910111213141516171819202122#!/bin/bashset -- $(getopt -q ab:cd &quot;$@&quot;)while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found -a&quot; ;; -b) para=&quot;$2&quot; echo &quot;Found -b, parameter=$para&quot; shift ;; -c) echo &quot;Found -c&quot; ;; -d) echo &quot;Found -d&quot; ;; --) shift break ;; *) echo &quot;$1 is not a option&quot; ;; esac shiftdonefor para in $@do echo &quot;Parameter $para&quot;done 但是getopt任然存在一个小问题：getopt并不擅长处理带引号和空格的场景，对于上述代码，下面的方法可以解决这个问题。 12345678$ ./test.sh -a -b test1 -cd &quot;test2 test3&quot; test4Found -aFound -b, parameter=test1Found -cFound -dParameter 'test2Parameter test3'parameter 'test4' getopts命令。与getopt不同，前者将命令行上选项和参数处理后只生成一个输出，而getopts命令能够和已有的shell参数变量配合。每次调用它时，它一次处理命令行上检测的一个参数。处理完所有参数后，它会退出并返回一个大于0的退出码。可以和循环命令结合使用。命令格式如下： 1getopts optstring variable 其中optstring和getopt命令类似，注意如果需要去掉错误信息的话，可以在optstring之前加一个冒号。getopts命令将当前参数保存在命令行中定义的variable中。getopts命令会用到两个环境变量，如果选项需要跟一个参数值，OPTARG环境变量就会保存这个值。OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。 12345678910#!/bin/bashwhile getopts :ab:c optdo case &quot;$opt&quot; in a) echo &quot;Found -a&quot; ;; b) echo &quot;Found -b, parameter $OPTARG&quot; ;; c) echo &quot;Found -c&quot; ;; *) echo &quot;Unknown option $opt&quot; ;; esacdone 注意对于$OPTARG如果包含空格需要用引号包裹。 1234$ ./test.sh -ab &quot;test1 test2&quot; -cFound -aFound -b, parameter test1 test2Found -c 初次之外，getopts将命令行上找到的所有未定义的选项统一输出为问号。 12345$ ./test.sh -ab &quot;test1 test2&quot; -c -dFound -aFound -b, parameter test1 test2Found -cUnknown option ? getopts只会处理选项参数，可以使用shift结合OPTIND环境变量来解析后续参数。 1234567891011121314151617#!/bin/bashwhile getopts :ab:c optdo case &quot;$opt&quot; in a) echo &quot;Found -a&quot; ;; b) echo &quot;Found -b, parameter $OPTARG&quot; ;; c) echo &quot;Found -c&quot; ;; *) echo &quot;Unknown option $opt&quot; ;; esacdoneshift $[ $OPTIND - 1 ]for para in &quot;$@&quot;do echo &quot;Parameter $para&quot;done 这样就可以处理了， 12345678910111213$ ./test.sh -ab &quot;test1 test2&quot; -c test3 test4Found -aFound -b, parameter test1 test2Found -cParameter test3Parameter test4$ ./test.sh -ab test1 test2 -c test3 test4Found -aFound -b, parameter test1Parameter test2Parameter -cParameter test3Parameter test4 不过需要注意getopts解析时需要把选项放在参数之前，这点和getopt不一样，对于getopt或默认把参数整理出来放在最后。 12$ getopt ab:c -ab test1 test2 -c test3 test4 -a -b test1 -c -- test2 test3 test4 读取用户输入 基本的读取。read命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后read命令会将数据存在一个变量里。 12read nameecho &quot;I'm $name&quot; read命令包含了-p选项能够在命令行指定提示符 12read -p &quot;Who are you?&quot; nameecho &quot;I'm $name&quot; read可以指定多个变量，输入的每个数值都会分配给变量列表中的下一个变量，如果变量数量不够，剩下的数据就全部分配给最后一个变量。read也可以不指定变量，这样的话收到的任何数据都会在特殊环境变量REPLY中。 超时，限定数目。 -t选项指定了read命令等待输入的秒数，当计时器过期之后，read命令返回一个非零退出码。 也可以不对输入过程计时，而是让read命令来统计输入的字符数。使用-n选项加上一个数字代表接受多少个字符。 隐藏输入。使用-s命令避免read命令中输入的数据出现在显示器上。 从文件中读取。每次使用read都会读取文件的一行，直到文件末尾，使用方式就是 cat + 管道 + while + read 。（done + 重定向也是可以的） 123456count=1cat test.txt | while read linedo echo &quot;$count $line&quot; count=$[ $count + 1 ]done 呈现数据输入和输出 标准文件描述符。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符。bash shell保留了前三个文件描述符。 0 STDIN 标准输入。 1 STDOUT 标准输出。当命令生成错误信息时，shell创建了输出重定向文件，但错误信息显示在显示屏上。如果使用输出重定向，此时错误信息不会出现在重定向的文件中。 2 STDERR 标准错误。默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给他们的文件描述符不同）。也就是说在默认情况下，错误信息也会显示在显示器上。但是STDERR不会随着STDOUT的重定向而发生改变。 重定向错误。 只重定向错误。可以选择只重定向错误信息，讲该文件描述符值放在重定向符号前（必须紧跟） 1$ ls -al badfile 2&gt; test 这样的话只会把错误进行重定向，标准输出还是会出现在屏幕上。 重定向错误和数据。 如果想要将两者标准输出和错误输出分开重定向。使用如下形式 1$ls -al goodfile badfile 1&gt; test1 2&gt; test2 如果想要将两者输出一起重定向，使用&amp;&gt;符号 1$ls -al goodfile badfile &amp;&gt; test 使用&amp;&gt;符号时，为了避免错误信息散落在输出文件中，相较于标准输出，bash shell自动赋予了错误信息更高的优先级，重定向后所有的错误信息会集中在开头。 脚本中重定向输出 临时重定向。如果有意在脚本中生成错误信息，可以将单独的一行输出重定向到STDERR。 1echo &quot;error message&quot; &gt;&amp;2 这行把echo命令的输出重定向到STDERR中。 永久重定向。可以使用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符。 12345exec 2&gt;errorfileecho &quot;normal message&quot;exec 1&gt;outputfileecho &quot;in output file&quot;echo &quot;in error file&quot; &gt;&amp;2 脚本中重定向输入 可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。exec命令允许你将STDIN重定向到Linux系统上的文件。 1exec 0&lt; testfile 创建自己的重定向 创建输出文件描述符。可以使用exec命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件描述符分配给一个文件，这个重定向就会一直有效，直到重新分配。 12exec 3&gt;testfileecho &quot;test message&quot; &gt;&amp;3 重定向文件描述符。你可以分配另外一个描述符给标准文件描述符，反之亦然。可以使用这个方法恢复以重定向的文件描述符。 1234exec 3&gt;&amp;1exec 1&gt;testfileecho &quot;In file&quot;exec 1&gt;&amp;3 上面这个例子先把3重定向到1的当前位置，然后把1重定向到testfile文件，现在echo命令的输出会出现在文件中，然后再把1重定向到3的位置，也就是恢复了原来的STDOUT。这是一种再脚本中临时重定向输出，然后恢复默认输出设置的常用方法。 创建输入文件描述符。相似的也可以临时重定向STDIN然后恢复 1234567exec 6&lt;&amp;0exec 0&lt;testfilewhile read linedo echo $linedoneexec 0&lt;&amp;6 创建读写描述符。由于是对同一个文件进行读写，shell会维护一个内部指针，指明在文件中的当前位置，任何读写都会从文件指针上次的位置开始。需要特别小心，可以看下面这个例子。 1234567891011121314151617$ cat test.sh#!/bin/bashexec 3&lt;&gt; testfileread line &lt;&amp;3echo &quot;Read: $line&quot;echo &quot;This is a test line&quot; &gt;&amp;3$ cat testfileThis is the first line.This is the second line.This is the third line.$ ./test.shReAD: This is the first line.$ cat testfileThis is the first line.This is a test lineine.This is the third line. 可以发现在对于testfile文件进行一次读取后，指针位于第二行的开头，这时写入的话会覆盖文件第二行的内容。 关闭文件描述符。如果创建了新的输入或输出文件描述符，shell会在脚本退出是自动关闭他们。如果需要手动关闭，将它重定向到特殊符号&amp;-。下面的这段代码允许会报错。 1234exec 3&gt;testfileecho &quot;test message&quot; &gt;&amp;3exec 3&gt;&amp;-echo &quot;bad message&quot; &gt;&amp;3 如果随后在脚本中打开了同一个输出文件，shell会用一个新文件替换已有文件。（需要用&gt;&gt;） 列出打开的文件描述符 lsof命令会列出整个linux系统打开的所有文件描述符。该命令会产生大量输出，会显示当前系统上打开的每个文件的有关信息。这包括后台运行的所有进程以及登录到系统的任何用户。有大量的参数可以过滤输出，-p运行输出PID，-d指定需要显示的文件描述符编号，-a用于对于多个选项的输出求交。 阻止命令输出 如果想要丢弃某些输出。例如丢弃STDERR的输出，可以将其重定向到/dev/null文件。重定向到该位置的任何数据都会被丢掉。 1ls -al badfile testfile 2&gt; /dev/null 这种方式可以丢弃报错信息。 创建临时文件linux系统有特殊的目录，专供临时文件使用。linux使用/tmp目录来存放不需要永久保存的文件。大多数linux发行版配置了系统在启动时自动删除/tmp目录的所有文件。系统上的任何用户都有权限在读写/tmp目录中的文件。 mktemp命令可以用来创建临时文件，可以在/tmp目录中创建一个唯一的临时文件。会将文件的读写权限分配给文件的属主，并将用户设置为文件的属主，其他人没法访问它。 创建本地临时文件。默认情况下mktemp会在本地创建一个文件。要用mktemp命令在本地目录中创建一个临时文件，只需要指定一个文件名模板就可以了。模板可以包含任意文本文件名，在文件名末尾加上6个x就行了。mktemp命令会用6个字符码替换这6个x，保证文件名在当前目录是唯一的。mktemp命令的输出是文件名（相对路径），在脚本中使用这个命令时，可能要将文件名保存在变量中，这样就可以继续引用了。 1234567tmpfile=$(mktemp test.xxxxxx)exec 3&gt;$tmpfileecho &quot;first line&quot; &gt;&amp;3exec 3&gt;&amp;-echo &quot;file contains:&quot;cat $tmpfilerm -f $tmpfile 2&gt; /dev/null 在/tmp目录创建临时文件。-t选项会强制mktemp命令在系统的临时目录来创建该文件，此时mktemp返回临时文件的绝对路径。 创建临时目录。-d选项告诉mktemp命令创建一个临时目录。可以在这个临时目录下继续创建临时文件。 1234tmpdir=$(mktemp -d dir.xxxxxx)cd $tmpdirtmpfile1=$(mktemp temp.xxxxxx)tmpfile2=$(mktemp temp.xxxxxx) 记录消息 如果想要输出同时出现在显示屏和日志文件上，可以使用tee命令。tee从STDIN读取的数据发向两端，一端是STDOUT，另一端是命令行指定的文件tee file。 1date | tee testfile 注意默认情况tee会覆盖输出文件，如果需要追加写入需要使用-a选项。","link":"/2021/01/17/shell%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/"},{"title":"shell脚本控制","text":"shell 脚本控制处理信号 常见信号。 信号 值 描述 1 SIGHUP 挂起进程 2 SIGINT 终止进程 3 SIGQUIT 停止进程 9 SIGKILL 无条件终止 15 SIGTERM 尽可能终止 17 SIGSTOP 无条件停止，但不是终止 18 SIGTSTP 停止或暂停，但不是终止 19 SIGCONT 继续运行停止的进程 生成信号。bash shell运行用键盘上的组合键生成两种基本的信号。 中断进程。Ctrl+C组合键生成SIGINT，并将这个信号发送给在当前shell中运行的所有进程。 暂停进程。Ctrl+Z组合键生成SIGTSTP，停止shell中运行的任何进程。 1234$ sleep 100^Z[1]+ Stopped sleep 100$ 方括号中的数字是shell分配的作业号。如果shell会话中有已停止的作业，在退出shell时会提醒。 1234$ exitlogoutThere are stopped jobs.$ 被停止的进程可以使用ps命令查看。如果仍然想要退出只需要在输入一次exit命令，也可以使用kill命令手动终止。 123$ kill -9 141$[1]+ Killed sleep 100 捕获信号。trap命令允许你来指定shell脚本监看并从shell中拦截的linux信号。如果脚本收到了trap命令中列出的信号，该信号不再由shell处理，而是交由本地处理。 1trap commands signals 列出想要执行的命令，以及一组由空格分开的待捕获的信号。可以用数值或者信号名来指定信号。下面是一个例子 12345678trap &quot;receive a Ctrl+C&quot; SIGINTcount=1while [ $count -le 10 ]do echo &quot;Loop #$count&quot; sleep 1 count=$[ $count + 1 ]done 在上面的循环执行的过程中按Ctrl+C或显示receive a Ctrl+C。 捕获脚本退出。要捕获shell脚本的退出，只要在trap命令后加上EXIT信号就可以。 修改或移除捕获。 修改。只需要重新使用trap命令即可 移除。只需要在trap命令与希望恢复行为的信号列表之间加上--就可以了。也可以在trap命令后使用单破折号来恢复信号的默认行为。 后台运行脚本 后台运行脚本。只需要在命令后加上&amp;就可以了，注意这时脚本仍然会使用显示屏显示STDOUT和STDERR消息（重定向很重要）。 运行多个后台脚本。对于每个后台运行的进程都会分配作业号和进程号，可以使用ps命令查看，每一个后台进程都和终端会话联系在一起，如果终端会话退出。那么后台进程也会退出。（如果使用了后台进程并且打算退出进程，只有某些终端仿真器会在退出时提醒） 在非控制台下运行脚本可以使用nohup命令使得后台脚本能够在终端退出后继续运行。nohup命令的格式如下 1$ nohup test.sh &amp; 和普通后台进程一样，shell会给命令分配一个作业号，linux系统会为其分配一个PID号。区别在于，使用nohup时，如果关闭该会话，脚本会忽略终端会话发来的SIGHUP信号。同时进程会把STDOUT和STDERR的输出自动重定向到名为nohup.out的文件中。 作业控制 查看作业。jobs命令查看当前正在处理的作业。jobs命令会显示当前已停止/运行中的作业，以及作业号和命令。可以加上-l选项来显示作业的PID。jobs的输出如下 123$ jobs -l[1]+ 2333 Stopped ./test.sh [2]- 1314 Running ./test.sh &gt; test.out &amp; 输出中的+代表这个作业被当作默认作业。在使用作业控制命令时，如果未指定作业号，改作业就会被当作操作对象。当默认作业完成处理之后，-号的作业就成为下一个默认作业。任何时候都只有一个带+和一个带-的作业。 重启停止的作业。 后台模式重启。使用bg命令加上作业号（注意是作业号） 前台模式重启。使用fg命令加上作业号 调整谦让度linux中，由shell启动的所有进程的调度优先级默认都是相同的。调度优先级是一个整数值，从-20（最高优先级）到19（最低优先级）。默认情况下，bash shell以优先级0来启动所有进程。 nice命令。nice命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级允许，只要用nice命令的-n选项就可以了。 1$ nice -n 10 ./test.sh &gt; test.out &amp; 通过ps命令可以发现进程的NI值被设置为10。但是如果想要提高某个命令的优先级，会出现如下输出 12345$ nice -n -10 ./test.sh &gt; test.out &amp; [1] 2333$ nice: cannot set niceness: Permission denied [1]+ Done nice -n -10 ./test.sh &gt; test.out $ nice命令组织普通用户提高优先级，注意这里指定的命令执行了只是nice命令失败了。 renice命令。renice命令可以改变正在运行的程序的优先级， 1$ renice -n NI -p PID 通过-n选项指定优先级，-p选项指定PID即可。和nice命令一样renice也存在一些限制： 只能对于属于你的进程使用renice 只能通过renice命令降低优先级 root用户可以随意调整 定时运行程序用at命令来计划执行作业at命令会将作业提交到队列中，指定shell何时运行该作业。at的守护进程atd会以后台模式运行，检查作业队列来运行作业。atd守护进程会检查系统上的一个特殊目录（通常位于/var/spool/at）来获取用at命令提交的作业。默认情况下，atd守护进程会每60s检查一下这个目录。有作业时，atd守护进程会检查作业设置运行的时间。如果时间和当前时间匹配，atd守护检查就会运行此作业。 at命令的格式。 1at [-f filename] time 默认情况下，at命令读取STDIN的输入，可以使用-f选项指定脚本。time参数指定了何时运行该作业。如果时间已经错过，at命令会在第二天那个时间运行指定的作业。at命令可以识别多种时间的格式 标准的小时分钟格式。如10:10 AM/PM格式。如10:10 PM 特殊的可命名时间。如now、noon、midnight。 也可以用不同的日期格式指定特定的日期 标准日期格式。如MMDDYY、MM/DD/YY或DD.MM.YY。 文本日期。如Dec 25。 也可以使用时间增量。如当前时间+25min，明天10:15 PM，10:15+7天。 在你使用at命令时，作业会被提交到作业队列中，针对不同的优先级，存在26种不同的作业队列，作业队列通常用小写字母az和大写字母AZ来指代。字母排序越高，作业运行的优先级就越低。默认情况下提交到a队列，可以使用-q选项指定队列。 获取作业的输出。此时输出会以e-mail的形式发送，建议在脚本中加入重定向，如果输出不重要，可以使用at的-M选项来屏蔽作业的输出信息。 列出、删除等待的作业。 atq命令可以查看当前正在等待的作业。 atrm命令通过指定作业号来删除在队列中等待的作业。 安排定期执行的脚本linux使用cron程序来安排要定期执行的作业。 cron时间表。cron时间表采用一种特殊的格式来指定作业何时运行。格式如下： 1min hour dayofmonth month dayofweek command cron时间表允许你用特定值、取值范围（比如1-5）或者时通配符（*）来指定条目。下面是几个例子 123456789101112131415#在凌晨00:01运行1 0 * * * /home/yiming/test.sh#每个工作日23:59都进行备份作业23 59 * * 1-5 /home/yiming/test.sh23 59 * * 1,2,3,4,5 /home/yiming/test.sh#每分钟运行一次命令*/1 * * * * /home/yiming/test.sh#每个月的1号14:10运行10 14 1 * * /home/yiming/test.sh#每个月最后一天的00:01运行1 0 * * * [[ &quot;$(date +%d -d tomorrow)&quot; == &quot;01&quot; ]] &amp;&amp; /home/yiming/test.sh 命令列表必须指定要运行提交的命令或脚本的全路径名。cron会用提交作业的账号运行该脚本。 创建cron时间表。使用-l选项列出当前用户已有的时间表。使用-e选项添加cron时间表。 浏览cron目录。如果对于脚本运行的时间精度要求不高，使用预配置的cron脚本目录更方便，有四个/etc/cron.hourly/ /etc/cron.dayly/ /etc/cron.weekly/ /etc/cron.monthly/，直接把脚本复制到对应文件夹下即可。 anacron程序。cron程序默认linux一直开机，如果出现了关机后开机错过时间的情况不会重新执行。这个问题可以使用anacron程序解决，anacron程序只会处理位于cron目录下的程序，例如/etc/cron.monthly（不会处理/ect/cron.hourly下的程序）。他用时间戳来决定作业是否正常运行了。时间戳位于/var/spool/anacron。 使用新shell启动脚本可以将每次打开shell时需要运行的shell脚本放在$HOME/.bashrc文件中。","link":"/2021/01/18/shell%E8%84%9A%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"title":"shell脚本中使用函数","text":"shell脚本使用函数基本的脚本函数创建函数有两种形式可以用来在bash shell中创建函数。 第一种格式采用关键字function，后跟分配给该代码块的函数名。 123function name { commands} name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。 第二种格式更接近于其他编程语言中定义函数的方法。 123name() {commands} 函数名后的括号表明正在定义一个函数。 使用函数12345678910#!/bin/bashfunction func1 { echo &quot;example of function&quot;}count=1while [ count -le 5 ]do func1 count=$[ $count + 1 ]done 直接使用函数名调用即可，注意函数的声明一定要在函数调用之前。如果定义了两个相同名称的函数，后面的函数会覆盖前面的函数，并且不会出现报错。 函数返回值bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出码。 默认退出状态码默认情况下，函数的退出码时函数中最后一条命令返回的退出状态码。在函数执行后，可以用标准变量$?来确定函数的退出状态码。 123456789function func1 { echo &quot;normal command&quot; ls -l badfile}function func2 { ls -l badfile echo &quot;normal&quot;} 执行func1得到的函数返回值是1，因为函数的最后一条命令没有正常退出，但是运行func2时返回值为0，即使在运行func2的时候有命令没有正常退出。所以使用函数的默认返回值是很危险的。 使用return命令bash shell使用return命令来退出函数并返回特定的退出状态码。 12345function db1 { read -p &quot;Enter a value:&quot; value echo &quot;doubling the value&quot; return $[ $value * 2 ]} 采用这种方式时需要注意两点 函数一结束就取返回值，否则$?变量会被覆盖 退出码必须是0~255 使用函数输出可以把函数的输出保存在变量中，例如result=$(func)这种方式。 12345function db1 { read -p &quot;Enter a value:&quot; value echo $[ $value * 2 ]}result=$(db1) 这种方法比较泛用。 在函数中使用变量向函数传递参数bash shell会将函数当作小型脚本来对待，这意味着可以像普通脚本那样向函数传递参数。函数可以使用标准的参数函数变量来表示命令行上传给函数的参数（$0 $1 $#）。在脚本中指定函数时，必须将参数和函数放在同一行，例如 1func1 $value1 10 下面是一个例子 12345678910function addem { if [ $# -eq 0 ] || [ $# -gt 2 ] then echo -1 elif [ $# -eq 1 ] echo $[ $1 + $1 ] else echo $[ $1 + $2 ] fi} 由于函数使用特殊参数环境变量作为自己的参数值，因此它无法直接获取脚本在命令行中的参数值。 在函数中处理变量 全局变量。如果在脚本的主体部分定义了一个全局变量，那么可以在函数内读取它的值。类似的，如果在函数内定义了一个全局变量，可以在脚本的主体部分读取它的值。默认情况下，在脚本中定义的任何变量都是全局变量。 1234567function db1 { value=$[ $value * 2 ]}read -p &quot;Enter a value:&quot; valuedb1echo &quot;The new value is: $value&quot; 这样其实很危险，如果想要在不同的shell脚本中使用函数的话。要求需要知道函数中使用了哪些变量。 局部变量。想要声明局部变量，只要在变量声明的前面加上local就可以了，也可以在变量的赋值时使用local。 数组变量和函数向函数传递数组参数将数组变量当作单个参数传递的话，并不会起作用 12345678function testit { echo &quot;The parameter are: $@&quot; thisarray=$1 echo &quot;The received array is ${thisarray[*]}&quot;}myarray=(1 2 3 4 5)echo &quot;The original array is: ${myarray[*]}&quot;testit myarray 这段代码的输出如下 123The origin array is: 1 2 3 4 5The parameter are: 1The received array is 1 这表明如果试图将数组变量作为函数参数，函数只会取数组变量的第一个值。 要解决这个问题，必须将该数组变量的值分解为单个的值，然后将这些值作为参数。在函数内部，可以将这些值重新组合成一个新的变量。下面是一个例子。 12345678910111213141516#!/bin/bashfunction testit { local newarray local sum=0 newarray=($(echo &quot;$@&quot;)) echo &quot;The new array value is: ${newarray[*]}&quot; for value in ${newarray} do sum=$[ $sum + $value ] done echo $sum}myarray=(1 2 3 4 5)echo &quot;The original array is: ${myarray[*]}&quot;result=$(testit ${myarray[*]})echo &quot;result is $result&quot; 这样的输出就是正确的了。 从函数返回数组函数用echo语句来按照顺序输出数组中的值，在调用处进行处理就可以了。 1234567891011121314151617181920#!/bin/bashfunction arraydblr { local origarray local newarray local elements local i origarray=($(echo &quot;$@&quot;)) newarray=($(echo &quot;$@&quot;)) elements=$[ $# - 1 ] for (( i=0; i &lt;= $elements; i++ )) do newarray[$i]=$[ ${origarray[$i]} * 2 ] done echo ${newarray[*]}}myarray=(1 2 3 4 5)echo &quot;The original array is: ${myarray[*]}&quot;result=($(testit ${myarray[*]}))echo &quot;The new array is: ${result[*]}&quot; 函数递归注意local的使用 12345678910function factorial { if [ $1 -eq 1 ] then echo 1 else local temp=$[ $1 - 1 ] local result=$(factorial $temp) echo $[ $result * $1 ] fi} 创建库使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令（./lib.sh命令没有用因为会创建新的shell运行，函数没有装载到当前的上下文）。source命令有个快捷的别名，点操作符，. ./lib.sh。 在命令行上使用函数在命令行上创建函数 单行方式在命令行创建函数。 1$ function div { echo $[ $1 / $2 ]; } 注意每条命令之后都要加上分号。 多行方式定义函数。 1234$ function div {&gt; echo $[ $1 / $2 ]&gt; }$ 小心函数名和已有的命令名重合。 在.bashrc中定义函数 直接在.bashrc中定义函数 定义在其他文件中，然后在.bashrc中使用source语句装载 1234if [ -r /home/yiming/lib.sh ]then . /home/yiming/lib.shfi","link":"/2021/01/19/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0/"},{"title":"sed,gawk基础与正则表达式","text":"sed基础，gawk基础，正则表达式sed 编辑器sed简单应用sed编辑器被称为流编辑器，流编辑器会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。sed可以根据命令来处理数据流中的数据，这些命令要么从命令行中输入，要么存储在一个命令文本文件中。sed编辑器会执行下列操作。 一次从输入中读取一行数据 根据所提供的编辑器命令匹配数据 按照命令修改流中的数据 将新的数据输出到STDOUT sed命令的格式如下 1sed options script file 根据选项可以修改sed命令的行为， -n。不产生命令输出，使用print命令来完成输出。 -e script。在处理输入时，将script中指定的命令添加到已有的命令中。（命令行输入，多个-e script组合） -f file。在处理输入时，将file中指定的命令添加到已有的命令中。（文件输入） -i。之间编辑文件命令。 在命令行定义编辑器命令默认情况下，sed编辑器会将指定的命令应用到STDIN输入流上。可以直接通过管道输入sed编辑器进行处理。 123$ echo &quot;This is a test&quot; | sed 's/test/big test/' This is a big test$ 在上面的示例中使用管道对sed编辑器输入文本，然后使用s命令对于文本进行替换，这里的s/test/big test/代表把test全部替换成big test。 sed编辑器不会修改文本文件的数据，它只会将修改后的数据发送到STDOUT中。 在命令行使用多个编辑器命令要在sed命令行上执行多个命令时，使用-e选项 1234567891011121314151617181920212223$ cat data1.txtThe quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy dog.$ sed -e 's/brown/green/; s/dog/cat/' data1.txtThe quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.$ sed -e 's/brown/green/' -e 's/dog/cat/' data1.txtThe quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.$ sed -e '&gt; s/brown/green/&gt; s/dog/cat/&gt; ' data1.txtThe quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat. 注意使用分号时在命令末尾和分号之间不能有空格。如果使用多行模式必须在封尾单引号所在行结束命令。 从文件读取编辑器命令如果有大量要处理的sed命令，可以使用-f选项从文件中读取。 12345678$ cat script1.seds/brown/green/s/dog/cat/$ sed -f script1.sed data1.txtThe quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat.The quick green fox jumps over the lazy cat. sed编辑器基础更多的替换选项 替换标记。上面使用的默认形式s/dog/cat/这种形式默认只会替换每行的第一个出现的dog。事实上，要让替换命令能够替换一行中不同地方出现的文本必须使用替换标记。替换标记会在替换命令字符串之后设置。 1s/pattern/replacement/flags 有四种可用的替换标记 数字，表明新文本将替换第几次模式匹配的地方。 g，表明新文本会替换所有的匹配文本。 p，表明原先行的内容要打印出来。 w file，将替换的结果写到文件中。 123456789101112131415$ cat data4.txtThis is a test of the test scriptThis is the second test of the test script$ sed 's/test/trail/2' data4.txtThis is a test of the trail scriptThis is the second test of the trail script$ sed 's/test/trail/g' data4.txtThis is a trail of the trail scriptThis is the second trail of the trail script$ sed 's/test/trail/gw temp' data4.txtThis is a trail of the trail scriptThis is the second trail of the trail script$ cat tempThis is a trail of the trail scriptThis is the second trail of the trail script p替换标记会输出修改过的行，一般和sed的-n选项一起使用。注意sed编辑器的正常输出在STDOUT中，只有那些包含匹配模式的行才会被w替换选项保存。 替换字符。替换文件中的路径名可能会非常麻烦。例如 1$ sed 's/\\/bin\\/bash/\\/bin\\/csh/' /etc/passwd 要解决这个问题，sed编辑器允许选择其他字符来作为替换命令的字符串分隔符 1$ sed 's!/bin/bash!/bin/csh!' /etc/passwd 使用地址 默认情况下，sed会处理所有行。如果只想命令作用于特定行或某些行，则必须使用行寻址。有两种行寻址方式。两种形式都使用相同的格式来指定地址。 1234567[address]commandaddress { command1 command2 ...} 以数字形式表示行区间。 用单个行号指定一行。 123456$ sed '2s/dog/cat/' data1.txtThe quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy cat.The quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy dog.$ 使用行号区间，起始行号+逗号+结束行号。 1234567891011$ sed '1,3s/dog/cat/' data1.txtThe quick brown fox jumps over the lazy cat.The quick brown fox jumps over the lazy cat.The quick brown fox jumps over the lazy cat.The quick brown fox jumps over the lazy dog.$ sed '2,$s/dog/cat/' data1.txtThe quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy cat.The quick brown fox jumps over the lazy cat.The quick brown fox jumps over the lazy cat.$ 注意这里可可用使用$来代表最后一行。 用文本模式过滤。sed编辑器允许指定文本模式来过滤出命令要作用的行。格式如下： 1/pattern/command 这里必须使用正斜线把pattern包裹起来。 12345$ sed '/quick/{s/dog/cat/; s/fox/tiger/}' data1.txtThe quick brown tiger jumps over the lazy cat.The quick brown tiger jumps over the lazy cat.The quick brown tiger jumps over the lazy cat.The quick brown tiger jumps over the lazy cat. 这里的pattern都是采用正则表达式匹配的。 同时这种方式也可用使用区间模式。 1/pattern1/,/pattern2/command 这种情况下会先找到pattern1作为开始模式，找到后对于后面紧跟的所有行都执行命令command，直到遇到pattern2命令结束，特别需要小心的一点是可能有多个区间被匹配到，造成不可知的结果，尽量少用。 命令组合。下面是一个组合命令 12345$ sed '/quick/{s/dog/cat/; s/fox/tiger/};2,3{s/cat/dog/;s/jump/run/}' data1.txtThe quick brown tiger jumps over the lazy cat.The quick brown tiger runs over the lazy dog.The quick brown tiger runs over the lazy dog.The quick brown tiger jumps over the lazy cat. 删除行 删除命令d它常常和上面的行寻址配合起来使用。例如 123456789$ cat data6.txtThis is line number 1.This is line number 2.This is line number 3.This is line number 4.$ sed '3d' data6.txtThis is line number 1.This is line number 2.This is line number 4. 插入和附加文本sed有两个插入操作。 i命令会在指定行前增加一个新行。 a命令会在指定行后增加一个新行。 格式如下： 12sed '[address]command\\new line' 下面是一个例子。 1234567891011$ sed '3a\\&gt; insert1&gt; 4i\\&gt; intert2' data6.txtThis is line number 1.This is line number 2.This is line number 3.insert1intert2This is line number 4.$ 从这个例子可以发现插入的语句是不会进入行计算里面的。（因为这里的This is line number 4.一直被当作第4行） 修改行sed中使用c命令来对行进行修改。格式和上面的插入相似，需要单独指定新行。 1234567$ sed '3c\\&gt; New Line' data6.txtThis is line number 1.This is line number 2.New LineThis is line number 4.$ 注意对于修改行命令我们也可以使用行区间的模式，但是c命令会把所有行替换为一行。 12345$ sed '2,$c\\&gt; New Line' data6.txtThis is line number 1.New Line$ 转换命令转换命令y是唯一可以处理单个字符的sed编辑器命令。格式如下 1[address]y/inchars/outchars/ y会对inchars和outchars进行一一映射，注意inchars和outchars长度需要相等。下面是一个例子 123456$ sed 'y/123/789/' data6.txtThis is line number 7.This is line number 8.This is line number 9.This is line number 4.$ 打印有三个命令能够用来打印数据流中的信息： p命令用来打印文本行。p命令一般和-n选项组合，配合行寻址。例子如下 1234$ sed -n '/3/{p;s/line/test/p}' data6.txtThis is line number 3.This is test number 3.$ =命令来打印行号。等号命令会打印行在数据流中的当前行号。例子如下 1234567891011121314$ sed -n '3{=;p;s/line/test/p}' data6.txt3This is line number 3.This is test number 3.$ sed '=' data6.txt1This is line number 1.2This is line number 2.3This is line number 3.4This is line number 4.$ l命令用来列出行。l命令可以打印数据流中不可打印的ASCII字符。任何不可打印字符要么在其八进制前加一个反斜线，要么使用C分格命名法（例如\\t）。 sed处理文件 写入文件。使用w命令可以写入文件。格式如下 1[address]w filename 将对应的行写入到文件中。 读取文件。r命令允许将一个独立文件的数据插入到数据流中。格式如下 1[address]r filename 这个命令如果不加地址会把r命令指定的文件内容插入到数据流的每一行后。例子如下 12345678910$ sed '/1/r data1.txt' data6.txtThis is line number 1.The quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy dog.The quick brown fox jumps over the lazy dog.This is line number 2.This is line number 3.This is line number 4.$ gawk 程序 虽然sed编辑器时非常方便自动修改文本文件的工具，但也有自身的限制。gawk能提供一个类编程环境来修改和重新组织文件中的数据。gawk提供了一种编程语言，可以做如下的事： 定义变量来保存数据。 使用算术和字符串操作来处理数据。 使用结构化编程（例如if-then语句和循环）。 通过提取数据文件中的数据元素，将其重新排序或格式化，生成格式化报告。 gawk程序的报告生成能力通常用来从大文件文本中提取数据元素，并将它们格式化成可读的报告。其中最完美的例子是格式化日志文件。 gawk简单应用gawk命令格式gawk程序的基本格式如下： 1gawk options program file 下面是gawk程序的一些可用选项 -F fs。指定行中划分数据字段的分段分隔符。 -f file。从指定文件中读取程序。 -v var=value。定义gawk程序中的一个变量及其默认值。 -mf N。指定要处理的数据文件中的最大字段数。 -mr N。指定数据文件中的最大数据行数。 -W keyword。指定gawk的兼容模式或警告等级。 gawk的强大之处在于程序脚本。可以写脚本来读取文本行的数据，然后处理并显示数据，创建任何类型的输出报告。 从命令行读取程序脚本gawk程序脚本用一对花括号来定义。必须将脚本命令放到两个花括号中。由于gawk命令行假定脚本是单个文本字符串，必须将脚本放到单引号中。下面是一个例子 1$ gawk '{print &quot;Hello World!&quot;}' 上面的例子使用了print命令，它会打印输出到STDOUT中，但是因为上面的命令没有指定文件，它会从STDIN读取输入。在运行的过程中它会一直等待STDIN的输入文本。如果输入一行文本然后按下回车键，gawk就会运行指定的脚本，在这个例子中就是打印一行Hello World!。 使用数据字段变量gawk会自动给一行中的每个数据元素分配一个变量。默认情况下，gawk会将如下变量分配给它在文本行中发现的数据字段。 $0代表整个文本行 $1代表文本行中的第一个数据字段 $n代表文本行中的第n个数据字段 在文本行中，每个数据字段都是通过字段分隔符划分的。gawk在读取一行文本时会用预定的字段分隔符划分每个数据字段。默认的时任意的空白字符。下面是一个例子 123456789101112131415161718192021$ cat data2.txtOne line of test text.Tow line of test text.Three line of test text.$ gawk '{print $1}' data2.txtOneTowThree$ gawk -F: '{print $1}' /etc/passwdrootdaemonbinsyssyncgamesmanlpmailnewsuucp[...] 在程序脚本中使用多个命令和sed类似，可以使用加分号和多行两种方式。 123456$ echo &quot;My name is Rich&quot; | gawk '{$4=&quot;Christine&quot;; print $0}'My name is Christine$ echo &quot;My name is Rich&quot; | gawk '{&gt; $4=&quot;Christine&quot;&gt; print $0}'My name is Christine 从文件中读取程序使用-f命令就可以指定文件。下面是一个例子 1234567891011121314$ cat script3.gawk{test = &quot;'s home directory is &quot;print $1 test $6}$ gawk -F: -f script3.gawk /etc/passwdroot's home directory is /rootdaemon's home directory is /usr/sbinbin's home directory is /binsys's home directory is /devsync's home directory is /bingames's home directory is /usr/games[...]$ 这里需要注意gawk程序在引用变量值时并未像shell脚本一样使用美元符。 在处理数据前后运行脚本可以使用BEGIN关键字和END关键字来分别定义在数据处理前后的行为。下面时一个例子 1234567891011121314151617181920212223242526$ cat script4.gawkBEGIN {print &quot;The latest list of users and shells&quot;print &quot; UserID \\t Shell&quot;print &quot;------- \\t ---------&quot;FS=&quot;:&quot;}{print $1 &quot; \\t &quot; $7}END {print &quot;This concludes the listing&quot;}$ gawk -f script4.gawk /etc/passwdThe latest list of users and shells UserID Shell------- ---------root /bin/bashdaemon /usr/sbin/nologinbin /usr/sbin/nologinsys /usr/sbin/nologinsync /bin/syncgames /usr/sbin/nologin$ 正则表达式正则表达式类型在linux中，有两种流行的正则表达式引擎： POSIX基础正则表达式（BRE）引擎 POSIX扩展正则表达式（ERE）引擎 sed编辑器符合BRE引擎，使用ERE引擎对应的符号需要使用转义，gawk程序用ERE引擎来处理它的正则表达式。 定义BRE模式纯文本简单的文本匹配，不包含特殊字符。 特殊字符正则表达式识别的特殊字符包括.*[]^${}\\+?|()。如果需要以纯文本模式匹配这些字符，需要使用\\进行转义。例如 123$ echo &quot;The cost is \\$4.00&quot; | sed -n '/\\$/p'The cost is $4.00$ 最后，尽管/不是一个特殊字符，但是在sed和gawk中使用时仍然需要转义。 123$ echo &quot;3 / 2&quot; | sed -n '/\\//p'3 / 2$ 锚字符 锁定在行首。^定义从数据流中文本行的行首开始的模式，会在每个由换行符决定的新数据行的行首检查模式。如果将^放到模式开头之外的其他位置，那它就跟普通字符一样，不再是特殊字符。 12345678$ echo &quot;sdas ^&quot; | sed -n '/^/p'sdas ^$ echo &quot;sdas ^&quot; | sed -n '/s ^/p'sdas ^$ echo &quot;sdas ^&quot; | sed -n '/^s/p'sdas ^$ echo &quot;sdas ^&quot; | sed -n '/^a/p'$ 锁定在行尾。$定义从数据流中文本行的行首开始的模式。和^完全类似。 组合使用。如果^和$组合使用，表示匹配只包含中间内容的行，特别的^$可以用来匹配空行。 点号字符.用来匹配除了换行符之外的任意单个字符。它必须匹配一个字符。 1234$ echo &quot;at&quot; | sed -n '/.at/p'$ echo &quot; at&quot; | sed -n '/.at/p' at$ 字符组使用方括号[]来定义一个字符组。方括号中包含所有希望出现在改字符组中的字符。 123$ echo &quot;Yes&quot; | sed -n '/[Yy][Ee][Ss]/p'Yes$ 排除型字符组在字符组的开头加上^可以反转字符组，去匹配没有在字符组中出现的字符。 12345$ echo &quot;hat&quot; | sed -n '/[^ch]at/p'$ echo &quot;at&quot; | sed -n '/[^ch]at/p'$ echo &quot; at&quot; | sed -n '/[^ch]at/p' at$ 区间可以使用单破折线符号-在字符组中表示字符。例如[1-9][a-g][a-ch-m]。 特殊字符组 组 描述 [[:alpha:]] a-z,A-Z [[:alnum:]] 0-9,a-z,A-Z [[:blank:]] 空格或者制表符 [[:digit:]] 0-9 [[:lower:]] a-z [[:upper:]] A-Z [[:print:]] 任意可打印字符 [[:punct:]] 标点符号 [[:space:]] 任意空白字符 星号在字符后面放置型号*表明该字符必须在匹配模式的文本中出现0次或者多次（注意这里和通配符*是不同的，不能混淆） 1234$ echo &quot;ik&quot; | sed -n '/ie*k/p'ik$ echo &quot;ieeeeek&quot; | sed -n '/ie*k/p'ieeeeek 扩展正则表达式注意这里属于ERE的范畴，也就是说sed需要转义，gawk支持。 问号?表明前面出现的字符可以出现0次或者1次，sed中需要使用\\? 12345$ echo &quot;bt&quot; | gawk '/be?t/{print $0}'bt$ echo &quot;bt&quot; | sed -n '/be\\?t/p'bt$ 加号+表示前面的字符出现1次或者多次，sed中使用\\+ 123456$ echo &quot;bt&quot; | gawk '/be+t/{print $0}'$ echo &quot;bet&quot; | gawk '/be+t/{print $0}'bet$ echo &quot;bet&quot; | sed -n '/be\\+t/p'bet$ 使用花括号花括号允许为可重复的正则表达式指定一个上限。有两种形式 {m}。表示准确出现m次。 {m,n}。表示至少出现m次，至多出现n次。 {m,}。至少出现m次。 注意gawk程序默认不识别。必须指定--re-interval。注意在sed编辑器中是支持花括号的，只是需要使用转义\\{m\\} 1234$ echo &quot;bt&quot; | gawk --re-interval '/be{1}t/{print $0}'$ echo &quot;bet&quot; | gawk --re-interval '/be{1}t/{print $0}'bet$ 管道符号管道符号|相当于逻辑OR，只要两边的模式有一个匹配即可。同样sed中使用\\| 12345678910$ echo &quot;I'm a dog&quot; | gawk '/dog|cat/{print $0}'I'm a dog$ echo &quot;I'm a cat&quot; | gawk '/dog|cat/{print $0}'I'm a cat$ echo &quot;I'm a bird&quot; | gawk '/dog|cat/{print $0}'$ echo &quot;I'm a dog&quot; | sed -n '/dog\\|cat/p'I'm a dog$ echo &quot;I'm a cat&quot; | sed -n '/dog\\|cat/p'I'm a cat$ 表达式分组可以使用圆括号()进行分组。当使用分组时，该组合被当作一个字符，可以使用?+等特殊字符。注意在sed中也是支持圆括号的，需要使用转义\\(\\)在sed中，会保持\\(\\)匹配的字符，可以使用\\1进行提取，如果有多个\\(\\)都匹配成功，则使用\\2 \\3进行提取。 12345678910111213$ echo &quot;Saturday&quot; | gawk '/Sat(urday)?/{print $0}'Saturday$ echo &quot;Sat&quot; | gawk '/Sat(urday)?/{print $0}'Sat$ echo &quot;Sat&quot; | sed -n '{/Sat\\(urday\\)\\{0,1\\}/p;}'Sat$ echo &quot;Saturday&quot; | sed -n '{/Sat\\(urday\\)\\{0,1\\}/p;}'Saturday$ echo &quot;{1234567}&quot;|sed 's/{\\([0-9]*\\)}/\\1/'1234567$ echo &quot;Yes&quot; | sed 's!\\(Y\\|y\\)\\(E\\|e\\)\\(S\\|s\\)!\\3!'s$","link":"/2021/01/19/sed,gawk%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"sed,gawk进阶","text":"sed，gawk进阶sed进阶多行命令sed编辑器包含了三个可用来处理多行文本的特殊命令。 N：将数据流的下一行加进来创建一个多行组来处理。 D：删除多行组中的一行 P：打印多行组中的一行 next命令 单行的next命令。小写的n命令告诉sed编辑器移动到数据流中的下一文本行，而不用重新回到命令的最开始再执行一遍。通常sed再移动到数据流中的下一个文本行之前，会在当前行上执行完所有定义好的命令，n命令改变了这个流程。 123456789101112$ cat data1.txtThis is the header line.This is a data line.This is the last line.$ sed '/header/{n;d}' data1.txtThis is the header line.This is a data line.This is the last line.$ 合并文本行。n命令会将数据流中的下一文本航班移动到sed编辑器的工作空间（模式空间）。多行版本的next命令（N命令）会将下一文本行添加到模式空间已有的文本后。这样的作用是将数据流中的两个文本行合并到同一模式空间中。文本行仍然采用换行符分隔，但sed编辑器将两行文本当成一行来处理。下面是一个例子 12345678910$ cat data2.txtThis is the header line.This is the first data line.This is the second data line.This is the last data line.$ sed '/first/{N;s/\\n/ /}' data2.txtThis is the header line.This is the first data line. This is the second data line.This is the last data line.$ 如果要再数据文件中查找一个可能会分散在两行中的文本短语的话，这是个很实用的应用程序。下面是一个例子 12345678910111213141516171819$ cat data4.txtOn Tuesday, The Linux SystemAdministrator's group meeting will be held.All System Administrators should attend.$ sed 'N&gt; s/System\\nAdministrator/Desktop\\nUser/&gt; s/System Administrator/Desktop User/&gt; ' data4.txtOn Tuesday, The Linux DesktopUser's group meeting will be held.All System Administrators should attend.$ sed 's/System Administrator/Desktop User/&gt; N&gt; s/System\\nAdministrator/Desktop\\nUser/&gt; ' data4.txtOn Tuesday, The Linux DesktopUser's group meeting will be held.All Desktop Users should attend.$ 这里要注意一点，如果sed执行到最后一行的时候，这时N命令因为无法读取下一行会使得sed编辑器停止允许下面的命令，这时如果在N命令之后如果有针对单行的命令就无法允许，所以要记得把单行命令写在N命令之前，多行命令写在N命令之后。 多行删除命令sed编辑器提供了多行删除命令D，它只删除模式空间的第一行。该命令会删除到换行符（含换行符）为止的所有字符。 1234$ sed 'N;/System\\nAdministrator/D' data4.txtAdministrator's group meeting will be held.All System Administrators should attend.$ 下面的例子是删除数据流中出现在第一行的空行 123456789101112$ cat data5.txtThis is the header line.This is a data line.This is the last line.$ sed '/^$/{N;/header/D}' data5.txtThis is the header line.This is a data line.This is the last line.$ 注意这个程序只能删除第一个空行，如果出现了两个联系的空行，结果如下： 123456789101112131415$ cat data5.txtThis is the header line.This is a data line.This is the last line.$ sed '/^$/{N;/header/D}' data5.txtThis is the header line.This is a data line.This is the last line.$ 解释如下：首先sed尝试取匹配^$，发现第一行就是一个空行，匹配成功，开始执行{}中的命令，sed会将第二行添加入模式空间然后执行匹配，发现无法匹配。接着sed从第三行开始匹配空行，直到最后。所以一次D命令都没有执行。 D命令的独特之处在于强制sed编辑器返回到脚本的起始处，对同一模式空间中的内容重新执行这些命令（不会读取新的文本行）。下面是man sed对于d和D的解释： d Delete pattern space. Start next cycle.D If pattern space contains no newline, start a normal new cycle as if the d command was issued. Otherwise, delete text in the pattern space up to the first newline, and restart cycle with the resultant pattern space, without reading a new line of input. 多行打印命令多行打印命令P只打印模式空间中的第一行。 保持空间模式空间是一块活跃的缓冲区，在sed编辑器执行命令时它会保存带检查的文本。但它不是sed编辑器保存文本的唯一空间。sed编辑器有另一块称作保持空间的缓冲区域。在处理模式空间中的某些行时，可以用保持空间来临时保存一些行。有5条命令可以用来操作保持空间。 h。将模式空间复制到保持空间。 H。将模式空间附加到保持空间。 g。将保持空间复制到保持空间。 G。将保持空间附加到模式空间。 x。交换模式空间和保持空间的内容。 可以灵活使用上面的命令，例如 1234$ sed -n '/first/{h;n;p;g;p}' data2.txtThis is the second data line.This is the first data line.$ 可以达成翻转输出的效果。 排除命令排除命令!，让原本会起作用的命令不起作用（反作用）。下面时一个例子。 12345$ sed -n '/header/!p' data2.txtThis is the first data line.This is the second data line.This is the last data line.$ 看一下之前的例子的改写 12345678$ sed '$!N&gt; s/System\\nAdministrator/Desktop\\nUser/&gt; s/System Administrator/Desktop User/&gt; ' data4.txtOn Tuesday, The Linux DesktopUser's group meeting will be held.All Desktop Users should attend.$ 这里使用了$!N表示在最后一行时不会执行N，后面的命令也不会因为N命令的失败而停止。 下面时翻转输出的例子 1234567891011$ cat data2.txtThis is the header line.This is the first data line.This is the second data line.This is the last data line.$ sed -n '{1!G;h;$p}' data2.txtThis is the last data line.This is the second data line.This is the first data line.This is the header line.$ 当然对于翻转文件已经存在已有的命令tac了（正好时cat反过来写）。 改变流通常，sed编辑器会从脚本的顶部开始，一直执行到脚本的结尾（D命令是个例外）。sed编辑器提供了一个方法来改变脚本的执行流程，其结果与结构化编程类似。 分支sed编辑器提供了一种方法，可以基于地址、地址模式或地址区间排除一整块命令。这允许只对数据流中的特定行执行一组命令。 分支命令b的格式如下： 1[address]b [label] 其中address命令决定了哪些行的数据会触发分支命令。label参数定义了要跳转到的位置。如果没有label参数，会之间跳转脚本的结尾。 123456$ sed '{2,3b; s/This is/Is this/; s/line./test?/}' data2.txtIs this the header test?This is the first data line.This is the second data line.Is this the last data test?$ 如果不想直接跳转到脚本的结尾，则需要定义一个跳转的标签。从冒号开始，最多7个字符长度。 123456$ sed '{/first/b jump1; s/This is the/No jump on/;:jump1;s/This is the/Jump here on/}' data2.txtNo jump on header line.Jump here on first data line.No jump on second data line.No jump on last data line.$ 如果匹配了，分支语句会跳转到标签处，如果没有匹配则会一直运行下去（包括标签后的语句）。 同时，可以使用分支语句达到循环的效果。 12345678$ echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n '{:start;s/,//1p;/,/b start}'This is, a, test, to, remove, commas.This is a, test, to, remove, commas.This is a test, to, remove, commas.This is a test to, remove, commas.This is a test to remove, commas.This is a test to remove commas.$ 测试测试命令t也可以用来改变sed编辑器脚本的执行流程。测试命令会根据替换命令的结果跳转到某个标签，而不是根据地址进行跳转。如果替换命令成功匹配并替换了一个模式，测试命令就会跳转到指定的标签。测试命令和分支命令有相同的格式。 测试命令提供了一种简单的if-then语句。例如，已经做了一个替换，不需要再做另一个替换，那么就可以使用测试命令。 123456789101112131415161718192021$ sed '{&gt; s/first/matched/&gt; t&gt; s/This is the/No match on/&gt; }' data2.txtNo match on header line.This is the matched data line.No match on second data line.No match on last data line.$ echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n '{&gt; :start&gt; s/,//1p&gt; t start&gt; }'This is, a, test, to, remove, commas.This is a, test, to, remove, commas.This is a test, to, remove, commas.This is a test to, remove, commas.This is a test to remove, commas.This is a test to remove commas.$ 模式替代&amp;符号&amp;符号可以用来代替替换命令中匹配的模式。 123$ echo &quot;The cat sleeps in his hat.&quot; | sed 's/.at/&quot;&amp;&quot;/g'The &quot;cat&quot; sleeps in his &quot;hat&quot;.$ 替换单独的单词使用\\(\\)和\\1\\2组合。 123456789$ echo &quot;The System Administrator manual&quot; | sed '&gt; s/\\(System\\) Administrator/\\1 User/'The System User manual$ echo &quot;1234567&quot; | sed '{&gt; :start&gt; s/\\([0-9]\\+\\)\\([0-9]\\{3\\}\\)/\\1,\\2/&gt; t start}'1,234,567$ 在脚本中使用sed使用包装脚本实现sed编辑器脚本的过程很繁琐，可以将sed编辑器命令放到shell包装脚本中。不用每次都重新键入sed脚本。 重定向sed输出可以在脚本中使用$()将sed的输出保持在变量中，以备后用。 gawk进阶使用变量gawk编程语言支持两种不同类型的变量： 内建变量 自定义变量 gawk有一些内建变量。这些变量存放用来处理数据文件中的数据字段和记录的信息。也可以在gawk程序中创建自己的变量。 内建变量gawk程序使用内建变量来引用程序数据里的一些特殊功能。 字段和记录分隔符变量。数据字段是由字段分隔符来划定的。默认情况下，字段分隔符是一个空白字符（空格或者制表符）。下面是gawk数据字段和记录变量 变量 描述 FIELDWIDTHS 由空格分割的一列数字，定义了每个数据字段确切宽度 FS 输入字段分隔符 RS 输入记录分隔符 OFS 输出字段分隔符 ORS 输出记录分隔符 默认情况下，OFS是一个空格，如果输入print $1,$2,$3就会看到data1 data2 data3。 123456789$ cat data1data11,data12,data13,data14,data15data21,data22,data23,data24,data25data31,data32,data33,data34,data35$ gawk 'BEGIN{FS=&quot;,&quot;; OFS=&quot;--&quot;} {print $1,$2,$3}' data1data11--data12--data13data21--data22--data23data31--data32--data33$ FIELDWIDTHS变量运行不依赖字段分隔符来读取记录。在一些应用程序中，数据并没有使用字段分隔符，而是被放置在了记录中的特定列。这种情况下，必须设定FIELDWIDTHS变量来匹配数据在记录中的位置。 123456789$ cat data1b1005.3247596.37155-2.349194.0005810.1298100.1$ gawk 'BEGIN{FIELDWIDTHS=&quot;3 5 2 5&quot;} {print $1,$2,$3,$4}' data1b100 5.324 75 96.37155 -2.34 91 94.00058 10.12 98 100.1$ 一旦设定了FIELDWIDTHS的值，就不能再改变了，这种方法不适应于变长字段。 变量RS和ORS定义了gawk程序如何处理数据流中的记录。默认情况下，gawk将RS和ORS设为换行符。默认的RS值表明，输入数据流中的每行新文本就是一条新纪录。 数据变量。除了字段和记录分隔符变量外，gawk还提供了其他一些内建变量来帮助了解数据发生了什么变化，并提取shell环境的信息。 变量 描述 ARGC 当前命令行参数个数 ARGIND 当前文件在ARGV中的位置 ARGV 包含命令行参数的数组 CONVFMT 数字的转换格式，默认%.6g ENVIRON 当前shell环境变量及其值组成的关联数组 ERRNO 当读取或关闭文件发生错误时的系统错误号 FILENAME 用作输入的数据文件的文件名 FNR 当前数据文件中已处理过的记录数 IGNORECASE 设置为非0值的时候，忽略gawk命令中出现的字符大小写 NF 数据文件中的字段总数 NR 已处理的输入记录数 OFMT 数字的输出格式，默认值为%.6g RLENGTH 由match函数所匹配的字符串长度 RSTART 由match函数所匹配的字符串起始位置 其中，ARGC和ARGV变量允许从shell中获得命令行参数的总数已经它们的值。注意gawk并不会把程序脚本当作命令参数的一部分。同时注意在gawk中引用变量并不需要$符号。 123$ gawk 'BEGIN{print ARGC,ARGV[1]}' data12 data1$ ENVIRON变量中存储了当前shell的环境变量，使用字符串作为索引。 123$ gawk 'BEGIN{print ENVIRON[&quot;HOME&quot;]}'/home/yiming$ 要在程序中跟踪数据字段和记录时，变量FNR、NF和NR用起来比较方便。NF变量可以在不知道具体位置的情况下指定记录中的最后几个字段。 123456789$ gawk 'BEGIN{FS=&quot;:&quot;;OFS=&quot;:&quot;} {print $1,$(NF-1)}' /etc/passwdroot:/rootdaemon:/usr/sbinbin:/binsys:/devsync:/bingames:/usr/games[...]$ FNR变量含有当前数据文件中已处理过的记录数，NR变量包含已处理的输入记录数。 12345678$ gawk 'BEGIN{FS=&quot;,&quot;} {print $1,&quot;FNR=&quot;FNR,&quot;NR=&quot;NR}' data1 data1data11 FNR=1 NR=1data21 FNR=2 NR=2data31 FNR=3 NR=3data11 FNR=1 NR=4data21 FNR=2 NR=5data31 FNR=3 NR=6$ 自定义变量 gawk自定义的变量名可以是任意数目的字母、数字和下划线，但不能以数字开头且区分大小写。 在脚本中给变量赋值。在gawk中给变量赋值和在shell脚本中赋值类似。同时，在gawk的赋值语句中可以使用算术运算来处理数字值（数学运算包括%取模和^ **求幂）。 123456$ gawk 'BEGIN{testing=&quot;This is a test&quot;;print testing;testing=45;print testing}'This is a test45$ gawk 'BEGIN{x=4;x=x*2+3;print x}'11$ 在命令行上给变量赋值。在命令行进行赋值，允许你在正常代码之外赋值，即时改变变量的值。 123456789101112131415$ cat script1BEGIN{FS=&quot;,&quot;}{print $nn=1print $n}$ gawk -f script1 n=3 data1data13data11data21data21data31data31$ 这里一开始n=3，是由命令行设置的。 但是像上面这种赋值方式有一个问题，就是无法在BEGIN部分使用变量。 1234567891011121314$ cat script1BEGIN{FS=&quot;,&quot;print n}{print $n}$ gawk -f script1 n=3 data1data13data23data33$ 解决方式是使用-v选项。-v命令行参数必须放在脚本代码之前。 123456$ gawk -v n=3 -f script1 data13data13data23data33$ 处理数组 定义数组变量可以用标准赋值语句来定义数组变量。数组变量赋值的格式如下 1var[index] = element 其中var是变量名，index是关联数组的索引值，element是数据元素值。下面是一些例子 12345$ gawk 'BEGIN{capital[&quot;Illinois&quot;]=&quot;Springfield&quot;;print capital[&quot;Illinois&quot;]}'Springfield$ gawk 'BEGIN{var[1]=34;var[2]=3;total=var[1]+var[2];print total}'37$ 遍历数组变量如果要在gawk中遍历一个关联数组，可以用for语句的一种特殊形式 1234for (var in array){ statements} 要注意这里的var中存的是数组中的索引值。可以根据这个索引值得到数组中的数据 123456789101112131415$ gawk 'BEGIN{&gt; var[&quot;a&quot;]=1&gt; var[&quot;g&quot;]=2&gt; var[&quot;m&quot;]=3&gt; var[&quot;u&quot;]=4&gt; for (test in var)&gt; {&gt; print test,&quot;-&quot;,var[test]&gt; }&gt; }'u - 4m - 3a - 1g - 2$ 注意这里的索引值返回顺序不一定。 删除数组变量从关联数组中删除数组索引要使用特殊命令 1delete array[index] 使用模式正则表达式gawk可以使用正则表达式来选择程序脚本作用在数据流的哪些行上。在使用正则表达式时，正则表达式必须出现在它想要控制的程序脚本的左花括号前。 123$ gawk 'BEGIN{FS=&quot;,&quot;} /11/{print $1}' data1data11$ 注意这种方式下正则表达式也会匹配分隔符。 12345$ gawk 'BEGIN{FS=&quot;,&quot;} /,d/{print $1}' data1data11data21data31$ 匹配操作符匹配操作符允许将正则表达式限定在记录中的特定数据字段。匹配操作符是~。可以指定匹配操作符、数据字段变量以及要匹配的正则表达式。 123$ gawk -F, '$2 ~ /^data2/{print $0}' data1data21,data22,data23,data24,data25$ 这个例子是在第二个字段匹配^data2。 同时也可以使用!修饰~代表不匹配。 1234$ gawk -F, '$2 !~ /^data2/{print $0}' data1data11,data12,data13,data14,data15data31,data32,data33,data34,data35$ 数学表达式除了正则表达式，也可以在匹配模式中使用数学表达式。 12345678$ gawk -F: '$4 == 0{print $1}' /etc/passwdroot$ gawk -F: '$4 != 0{print $1}' /etc/passwddaemonbinsyssync$ 这里的$4 == 0就是一个数学表达式，表示第四个字段等于0的行。这里的数学表达式包括各种形式：== != &lt;= &gt;= &lt; &gt;。 当然也可以对文本数据使用表达式，和正则表达式不同，这里的表达式必须完全匹配。 1234$ gawk -F, '$1 == &quot;data11&quot;{print $1}' data1data11$ gawk -F, '$1 == &quot;data&quot;{print $1}' data1$ 结构化命令if语句12if (condition) statement1 使用方式和c语言相似。 12345678910111213141516171819202122232425262728$ cat data3Jones 2143 78 84 77Gondrol 2321 56 58 45RinRao 2122 38 37Edwin 2537 87 97 95Dayan 2415 30 47$ cat script2.gawk{total=$3+$4+$5avg=total/3if(avg&gt;=90){ grade=&quot;A&quot;}else if(avg&gt;=80){ grade=&quot;B&quot;}else if(avg&gt;=70){ grade=&quot;C&quot;}else if(avg&gt;=0 &amp;&amp; avg&lt;70){ grade=&quot;D&quot;}print $0,&quot;=&gt;&quot;,grade}$ gawk -f script2.gawk data3Jones 2143 78 84 77 =&gt; CGondrol 2321 56 58 45 =&gt; DRinRao 2122 38 37 =&gt; DEdwin 2537 87 97 95 =&gt; ADayan 2415 30 47 =&gt; D$ 另外gawk中也有?命令。 while语句1234while (condition){ statements} 使用方式和C语言一样。 do-while语句123do{ statements} while (condition) 使用方式和C语言一样。 for语句1for (variable assignment; condition; iteration process) 使用方式和C语言一样。 格式化打印gawk有类似c语言中的printf命令来进行格式化打印。printf的命令格式如下 1printf &quot;format string&quot;, var1, var2, ... 和c语言的printf一样，format string包含文本元素和格式化指定符。格式化指定符采用如下格式 1%[modifier]control-letter 其中control-letter是一个单字符代码，用于指明显示什么类型的数据，而modifier则定义了可选的格式化特性。下面列出了控制字母 控制字母 描述 c 将一个数作为ASCII字符显示 d 显示整数 i 显示整数 e 显示科学计数法 f 显示浮点数 g 显示科学计数法或浮点数（选择短的） o 显示8进制 s 显示字符串 x 显示十六进制 X 显示十六进制（大写） 还有3种修饰符可以进一步控制输出： 修饰符 描述 width 指定了输出字段最小宽度。是一个数字。如果输出短于这个值，输出右对齐，空格填充。 prec 指定了浮点数种小数点后的位数。是一个数字。或者字符串显示的最大字符数。 - 表明采用左对齐而不是右对齐。 下面是一个例子 12345678910111213141516$ cat data5130 120 135160 113 140145 170 215$ gawk '{total=0for(i=1;i&lt;=4;i++){total+=$i}avg=total/3printf &quot;Avg: %06.1f\\n&quot;, avg}' data5Avg: 0128.3Avg: 0137.7Avg: 0176.7$ 这里%5.1f代表输出一个浮点数，width=6并且用0填充，prec=1。 函数定义函数1234function name([variables]){ statements} 函数的使用方式基本和c语言完全一致 使用自定义函数和c语言调用函数的方式完全一致。 如果需要创建函数库，则需要先创建一个文件储存需要的函数，例如functionlib，需要使用这个函数库时，使用下面的方式调用 1$ gawk -f functionlib -f script data 内建函数除了自定义函数，gawk内部有很多内建函数 数学函数。 函数 描述 atan2(x,y) x/y的反正切 cos(x) exp(x) int(x) log(x) 求自然对数 rand() 生成0~1的随机浮点数 sin(x) sqrt(x) srand(x) 为随机数计算指定种子 除此之外，还有一些位运算相关的函数。 函数 描述 and(v1,v2) &amp; compl(val) ~ lshift(val,count) &lt;&lt; or(v1,v2) | rshift(val,count) &gt;&gt; xor(v1,v2) ^ 字符串函数。 函数 描述 asort(s [,d]) 将数组s按照元素值排序。索引值会替换成表示新的排序顺序的连续数字。如果指定了d排序后的数组会存在d中 asorti(s [,d]) 将数组s按照索引值排序。元素值会替换成表示新的排序顺序的连续数字，如果指定了d排序后的数组会存在d中 gensub(r, s, h [,t]) 在$0或目标字符串t中匹配r，如果h是g或者G则全部替换，如果是一个数字则替换第h次出现的地方 gsub(r, s [,t]) 在$0或目标字符串t中匹配r，并用s替换全部 index(s, t) 返回字符串t在s中的索引值 length([s]) 求长度，如果没有指定s则返回$0长度 match(s, r [,a]) 返回s中正则表达式r出现的位置的索引。如果指定了数组a，它会储存s中匹配的那部分 split(s, a [,r]) 将s用FS或r分割到数组a中。返回字段总数 sprintf(format, variavles) printf返回字符串 sub(r, s [,t]) 在$0或目标字符串t中匹配r，并用s替换第一处 substr(s, i [,n]) 返回s从索引i开始（索引从1开始）n个的子字符串，如果没有n就到结尾 tolower(s) 转小写 toupper(s) 转大写 时间函数。 函数 描述 mktime(datespec) 将一个YYYY MM DD HH MM SS[DST]格式的日期转化为时间戳 strftime(format[,timestamp]) 将当前时间的时间戳或timestamp转化为日期 systime() 当前时间的时间戳","link":"/2021/01/21/sed-gawk%E8%BF%9B%E9%98%B6/"},{"title":"linux 文件操作","text":"linux 文件操作linux 文件结构在linux中，一切皆文件。对应文件操作有5个基本的函数open，read，write，close，ioctl。linux中任何事物都可以用一个文件来表示，或者通过特殊的文件提供。下面是一些会用到的特殊文件。 目录目录是用于保存其他文件的节点号和名字的文件。目录文件中的每个数据项都是指向某个文件节点的链接。 文件和设备unix和linux中比较重要的设备文件有3个。 /dev/console。这个设备代表的是系统控制台。错误信息和诊断信息通常会被发送到这个设备。每个unix设备都会有一个指定的终端或显示屏来接收控制台消息。 /dev/tty。如果一个进程有控制终端的话，那么特殊文件/dev/tty就是这个控制终端。如果是系统自动允许的进程和脚本就没有控制终端，所以它们不能打开/dev/tty。在能够使用该设备文件的情况下，/dev/tty允许程序直接向用户提供输出信息，而不管用户具体使用的是什么类型的伪终端或硬件终端。/dev/console设备只有一个，/dev/tty能访问不同的物理设备。 dev/null。所有写向这个设备的输出都会被丢弃，所有读这个设备的操作会立刻得到一个文件尾标志。 系统调用和设备驱动程序只需要使用少量的函数就可以对文件和设备进行控制和访问。这些函数被称为系统调用。操作系统的核心部分，内核，是一组设备驱动程序。它们是一组对系统硬件进行控制的底层接口。为了向用户提供一个一致的接口，设备驱动程序封装了所有与硬件相关的特性。硬件特有的功能通常可以用ioctl系统调用来提供。/dev目录中的设备文件的用法是相同的，它们都可以被打开、读、写和关闭。下面是用于访问设备驱动程序的底层函数（系统调用）。 open：打卡文件或者设备 read：从打开的文件或设备写数据 write：向文件或者设备写数据 close：关闭文件或设备 ioctl：把控制信息传递给设备驱动程序。它踢馆一些与特定硬件有关的必要控制，用法随设备的不同而不同。 库函数直接使用底层系统调用的问题是效率低下。因为系统调用会影响系统的性能（系统调用相比一般的函数调用开销更大），硬件也会限制对底层系统调用一次所能读写的数据块的大小。linux发行版提供了一系列更高层的接口（标准函数库）。 底层文件访问write系统调用系统调用write函数的作用是把缓冲区buf的前nbytes个字节写入与文件描述符fildes关联的文件中。返回实际写入的字节数。如果文件描述符有错或者底层的驱动程序对数据块长度比较敏感，该返回值可能会小于nbytes。如果这个函数返回0，就表示没有写入任何数据；如果返回-1，就表示write在执行的过程中出现了错误，错误代表保存在全局变量errno里。 123#include &lt;unistd.h&gt;size_t write(int fildes, const void *buf, size_t nbytes); 下面是一个简单的程序 输出如下： 123$ ./simple_writeHere is some data$ 需要注意的是，write可能会报告写入的字节比要求的少，这不一定是一个错误。在程序中需要检测errno已发现错误，然后再次调用write写入剩余的数据。 read系统调用系统调用read的作用是：从与文件描述符fildes相关联的文件里读入nbytes个字节的数据，并把它们放到数据区buf中。返回实际读入的字节数。 123#include &lt;unistd.h&gt;size_t read(int fildes, void *buf, size_t nbytes); 下面的程序把标准输入的前128个字符复制到标准输出。如果输入少于128个字节，就把它们全体复制过去。 运行这个程序可以看到 123456$ echo &quot;Hello World&quot; | ./simple_readHello World$ ./simple_readread from stdinread from stdin$ open系统调用为了创建一个新的文件描述符，需要使用系统调用open 123456#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int open(const char *path, int oflags);int open(const char *path, int oflags, mode_t mode); 如果open调用成功，会返回一个可以被读写和使用的文件描述符。这个文件描述符数唯一的，不会和任何其他进程共享。如果两个进程打开同一个文件，那么两个进程会分别维护一个指针来代表当前读（写）操作应该从哪里开始，所有如果同时对于一个文件进行写操作，会相互覆盖。 准备打开的文件或设备的名字作为path传递给函数，oflags参数用于指定打开文件所采取的动作。下面是一些oflags。如果使用多个o_flags使用|进行连接。 模式 说明 O_RDONLY 只读 O_WRONLY 只写 O_RDWR 读写 O_APPEND 写入时追加在文件末尾 O_TRUNC 丢弃文件已有的内容 O_CREAT 如果需要，就按参数mode中的访问模式创建文件 O_EXCL 与O_CREAT一起使用，确保调用者创建出文件 open如果调用成功就返回一个文件描述符，如果调用失败就返回-1，新的文件描述符总是使用未用描述符的最小值。 任何一个运行中的程序能够同时打开的文件数时有限制的。这个限制通常是由limits.h头文件中的常量OPEN_MAX定义的，它的值随系统的不同而不同，但是POSIX要求至少16（同时受本地系统全局性限制的影响）。这个限制可以在运行时调整，所有OPEN_MAX不是一个常量。 访问权限的初始值当使用带有O_CREAT的open调用来创建文件时，必须使用有3个参数格式的open调用。第三个参数mode时几个标志按位或后得到的，这些标志再头文件sys/stat.h中定义： S_IRUSR，S_IWUSR，S_IXUSR。属主读写执行。 S_IRGRP，S_IWGRP，S_IXGRP。属组读写执行。 S_IROTH，S_IWOTH，S_IXOTH。其他用户读写执行。 下面是一个例子 1open(&quot;myfile&quot;, O_CREAT, S_IRUSR|S_IXOTH); 它创建了一个名为myfile的文件，文件属主有读权限，其他用户有执行权限。 有几个因素会对文件的访问权限产生影响。 指定的访问权限只有在创建文件时才会使用。 用户掩码（umask命令查看），简单来说，open调用里面的mode值会与当前用户掩码的反值做&amp;操作。 close系统调用使用close调用终止文件描述符与其对应文件之间的关联。文件描述符被释放并且能够被重新使用。close调用成功时返回0，出错时返回-1。 123#include &lt;unistd.h&gt;int close(int fildes); 注意在编程时检查close的返回值。 ioctl系统调用ioctl提供了一个用于控制设备及其描述符行为和配置底层服务的接口。终端、文件描述符、套接字甚至磁带机都可以有为它们定义的ioctl。 123#include &lt;unistd.h&gt;int ioctl(int fildes, int cmd, ...); （不做讨论了） 使用系统调用进行文件复制下面是一个简单的文件复制程序 这个程序每次读入一个字节，实现文件的复制，因为系统调用本身开销很大，所以可以用如下方式进行优化。 这里需要注意一点，#include &lt;unistd.h&gt;行必须首先出现，因为它定义的与POSIX规范有关的标志可能会影响到其他头文件。 其他系统调用lseek系统调用lseek系统调用对文件描述符fildes的读写指针进行设置。读写指针可被设置为文件的绝对位置，也可以被设置为相对于当前位置或文件尾的某个相对位置。 1234#include &lt;unistd.h&gt;#include &lt;sys/type.h&gt;off_t lseek(int fildes, off_t offset, int whence); 其中whence参数定义该偏移值的用法。whence可以取下列值之一。 SEEK_SET：offset参数指定的是一个绝对位置 SEEK_CUR：offset参数是相对于当前位置的一个位置 SEEK_END：offset是相对于文件尾的一个位置 lseek返回从文件头到文件指针被设置处的字节偏移值，失败时返回-1。参数offset的类型off_t与具体实现有关，定义在sys/types.h中。 fstat，stat，lstat系统调用fstat系统调用返回与打开文件描述符相关的文件的状态信息，该信息将会写到一个buf结构体中。stat和lstat会通过文件名查到对应的状态信息。如果文件是一个符号链接，lstat返回这个符号链接本身的信息，stat返回链接指向的文件的信息。 1234567#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;int fstat(int fildes, struct stat *buf);int stat(const char *path, struct stat *buf);int lstat(const char *path, struct stat *buf); stat结构的成员在不同类UNIX系统上会有所变化，但一般会包括下面的内容 stat成员 说明 st_mode 文件权限和文件类型信息 st_ino 与该文件关联的inode st_dev 保存文件的设备 st_uid 文件属主的UID号 st_gid 文件属主的GID号 st_atime 文件上一次被访问的时间 st_ctime 文件的权限、属主、组或内容上一次被改变的时间 st_mtime 文件的内容上一次被修改的时间 st_nlink 该文件上硬链接的个数 dup和dup2系统调用dup系统调用提供了一种复制文件描述符的方法，使得多个描述符描述同一个文件。dup复制文件描述符fildes，返回一个新的描述符。dup2则是把一个文件描述符复制为一个新的文件描述符，如果指定的新文件描述符已经被打开了，那么就先关闭之前的文件描述符，要注意在dup2中关闭和打开这个操作是原子的。 1234#include &lt;unistd.h&gt;int dup(int fildes);int dup2(int fildes, int fildes2); 标准I/O库在标准I/O库中，与底层文件描述符对应的是流，它被实现为指向结构FILE的指针。 在启动程序时，有三个文件流是自动打开的，stdin，stdout，stderr。 fopen函数fopen库函数类似于open系统调用。如果需要对应设备进行明确的控制，最后使用open系统调用，因为这可以避免用库函数带来的一些潜在问题，如输入/输出缓冲。 123#include &lt;stdio.h&gt;FILE *fopen(const char *filename, const char *mode); mode参数指定文件的打开方式， “r”或者”rb”，只读。文件必须存在，否则打开失败。 “w”或者”wb”，写方式打开，把文件长度截断为0（或者创建空文件） “a”或者”ab”，写方式打开，把新内容追加在文件尾（或者创建空文件） “r+”或者”rb+”，以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败。 “w+”或者”wb+”，以“写入/更新”方式打开文件，相当于w和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。 “a+”或者”ab+”，以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。 这里的”b”代表打开的是二进制文件。 fopen在成功时返回一个非空的FILE *指针，失败时返回NULL，NULL在stdio.h中被定义。 可用的文件流数量和文件描述符的数量一样都是有数量限制的。实际的限制是由头文件stdio.h中定义的FOPEN_MAX定义的，它的值至少是8。 fread函数fread函数用于从一个文件流里读取数据。数据从文件流stream读到ptr指向的数据缓冲区中，size参数指定一次读取的数据记录的长度，nitems指定要传输的记录的个数。返回值是成功读入的记录的数目。在fread中并没有区分发生错误和读完流，所以两种发生时返回值都是一个小于nitems的数，需要使用feof和ferror来判断是否有错误发生。 123#include &lt;stdio.h&gt;size_t fread(void *ptr, size_t size, size_t nitems, FILE *stream); fwrite函数与fread函数几乎完全一致 123#include &lt;stdio.h&gt;size_t fwrite(void *ptr, size_t size, size_t nitems, FILE *stream); fclose函数fclose关闭指定文件流stream，使所有尚未写出的数据都写出。 123#include &lt;stdio.h&gt;int fclose(FILE *stream); fflush函数fflush库函数的作用是把文件流里的尚未写出的数据立刻写出。 123#include &lt;stdio.h&gt;int fflush(FILE *stream); fseek函数fseek和lseek对应，其中的offset参数和whence参数完全一致，区别是lseek返回一个off_t数值，fssek返回一个整数：0表示成功，-1表示失败。 123#include &lt;stdio.h&gt;int fseek(FILE *stream, long int offset, int whence); fgetc，getc，getchar函数fgetc函数从流中读出下一个字符返回如果到文件尾或者遇到错误则返回EOF（-1）,需要使用feof和ferror进行区分。getc的作用和fgetc一致，但是getc有可能被作为一个宏实现。getchar的相当于getc(stdin)。 12345#include &lt;stdio.h&gt;int fgetc(FILE *stream);int getc(FILE *stream);int getchar(); 下面是一个使用标志输入输出库实现的复制程序。 fputc，putc，putchar函数这三个函数都是写入一个字符，具体差距见上面 12345#include &lt;stdio.h&gt;int fputc(int c, FILE *stream);int putc(int c, FILE *stream);int putchar(int c); fgets，gets函数这两个函数从流中读取字符串 1234#include &lt;stdio.h&gt;char *fgets(char *s, int n, FILE *stream);char *gets(char *s); fgets函数把读到的数据写入s中，直到遇到下面出现的其中一种情况： 遇到换行符 已经读取了n-1个字符 到达文件尾 它会把换行符也写入到s中，同时fgets会加上一个表示结尾的空字节\\0表示结束所以一次调用只能最多读取n-1个字符。调用成功时，fgets返回一个指向s的指针。如果遇到EOF或者错误则会返回NULL空指针。 gets函数类似fgets，但是只会读stdin，并且只会遇到换行符停止，并且在写入s时会抛弃最后的换行符，并且gets很有可能导致缓冲区溢出（少用） 格式化输入输出printf，fprintf，sprintf函数函数原型 12345#include &lt;stdio.h&gt;int printf(const char *format, ...);int sprintf(char *s, const char *format, ...);int fprintf(FILE *stream, const char *format, ...); printf函数输出到stdout，fprintf函数输出到指定的文件流，sprintf函数把自己的输出和一个结尾空字符写入字符串中。其他的printf系列函数可以在man 3 printf中查看。 普通字符在输出时不发生变化。转换控制符让printf取出传递过来的其他参数并对它们的格式进行编排。转换控制符总是以%开头。下面是一些常用的转换控制符。 %d，%i。十进制输出整数 %o。八进制输出 %x。十六进制输出 %c。输出一个字符 %s。输出一个字符串 %f。输出一个单精度浮点数 %e。科学计数法输出一个双精度浮点数 %g。以通用格式输出一个双精度浮点数 printf函数返回一个整数表示其输出的字符的个数，但是sprintf函数并没有把最后的\\0计算在内。 scanf，fscanf，sscanf函数函数原型 12345#include &lt;stdio.h&gt;int scanf(const char *format, ...);int fscanf(FILE *stream, const char *format, ...);int sscanf(const char *s, const char *format, ...); scanf系列函数和printf相反，是读取数据到变量中，这些变量的类型必须正确，并且它们必须精确匹配格式字符串，否则内存就会被破坏。（编译器并不会报错） 使用%[]控制符读取由一个字符串集合中的字符构成的字符串。格式字符串%[A-Z]将读取一个由大写字母构成的字符串。如果想要读取一个带空格的字符串，并且在换行符处停止，可以使用%[^\\n]来进行读取。 scanf函数的返回值是它成功读取的数据项的个数，如果在读取第一个数据项时失败了，返回0，如果达到了输入的结尾，就会返回EOF。如果文件流发生读错误，流错误标志就会被设置并且错误变量errno将被设置以指明错误类型。 其他流函数 fgetpos：获取文件流的当前（读写）位置 fsetpos：设置文件流的当前（读写）位置 ftell：返回文件流当前（读写）位置的偏移值 rewind：重置文件流内的读写位置 freopen：重新使用一个文件流 setvbuf：设置文件流的缓冲机制 remove：相当于unlink函数，如果path参数是一个目录的话，其作用就相当于rmdir函数 文件流错误为了表明错误，许多库函数会返回一个超出范围的值，例如控制针和EOF。此时，错误由外部变量errno指出。 123#include &lt;error.h&gt;extern int errno; 注意，许多函数都可能改变errno的值，它的值只有在函数调用失败之后才有意义。在函数使用失败后必须立刻对其进行检查。 也可以通过检查文件流的状态来确定是否发生了错误，或者是否到达了文件尾。 12345#include &lt;stdio.h&gt;int ferror(FILE *stream);int feof(FILE *stream);void clearerr(FILE *stream); ferror函数测试一个文件流的错误标识，如果该标识被设置就返回一个非0值，否则返回0。 feof函数测试一个文件流的文件尾标识，如果该标识被设置就返回一个非0值，否则返回0。 clearerr函数的作用是清除由stream指向文件流的文件尾标识和错误标识。可以通过使用这个函数从文件流的错误中恢复。 文件流和文件描述符每个文件流都和一个底层文件描述符相关联。可以把底层的输入输出操作和高层的文件流操作混合使用，一般来说这不是一个明智的做法，因为数据缓冲的后果难以预料。 1234#include &lt;stdio.h&gt;int fileno(FILE *stream);FILE *fdopen(int fildes, const char *mode); fileno函数可以确定文件流使用的文件描述符，如果失败就返回-1，如果需要对一个已经打开的文件流进行底层访问，这个函数很有用。fdopen在一个已经打开的文件描述符上创建一个新的文件流，事实上这个函数的作用是提供一个缓冲区。 文件和目录的维护chmod系统调用可以通过chmod系统调用来改变文件或目录的访问权限。 123#include &lt;sys/stat.h&gt;int chmod(const char *path, mode_t mode); path参数指定的文件被修改为具有mode参数给出的访问权限。 chown系统调用超级用户可以使用chown系统调用来改变文件的属主 1234#include &lt;sys/type.h&gt;#include &lt;unistd.h&gt;int chown(const char *path, uid_t owner, gid_t group); unlink，link，syslink系统调用12345#include &lt;unistd.h&gt;int unlink(const char *path);int link(const char *path1, const char *path2);int syslink(const char *path1, const char *path2); unlink系统调用删除一个文件的目录项并减少它的（硬）链接数。在成功时返回0，失败时返回-1。如果一个文件的链接数减少到0，并且没有进程打开它，这个文件就会被删除。link系统调用将创建一个指向已有文件path1的新链接，使用syslink创建符号链接。 mkdir和rmdir系统调用类比shell中的mkdir和rmdir程序 1234#include &lt;sys/types.h&gt;#include &lt;sys.stat.h&gt;int mkdir(const char *path, mode_t mode); 123#include &lt;unistd.h&gt;int rmdir(const char *path); chdir系统调用和getcwd函数chdir系统调用可以用来切换目录（相当于cd） 123#include &lt;unistd.h&gt;int chdir(const char *path); getcwd函数用来确定当前的工作目录 123#include &lt;unistd.h&gt;char *getcwd(char *buf, size_t size); getcwd函数把当前目录的名字写到给定的缓冲区buf里。如果目录名的长度超出了参数size给出的缓冲区长度，就会返回NULL，如果成功，返回指针buf。 扫描目录之前提到目录本身是一种特殊的文件，与目录操作相关的函数在dirent.h头文件中声明。 opendir函数1234#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;DIR *opendir(const char *name); opendir函数打开一个目录并且建立一个目录流。如果成功返回一个指向DIR结构的指针，如果失败返回一个空指针。注意，目录流使用一个底层的文件描述符来访问目录本身，如果打开文件过多，opendir可能失败。 readdir函数readdir函数返回一个指针，该指针指向的结构里保存着目录流dirp中下一个目录项的有关资料。后续的readdir调用将会返回后续的目录项。如果发生错误或者到达目录尾，则返回NULL。 1234#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;struct dirent *readdir(DIR *dirp); dirent结构中包含的目录项内容包括以下部分： ino_t d_ino：文件的inode节点号 char d_name[]：文件的名字 telldir，seekdir函数telldir函数的返回值记录一个目录流的当前位置，seekdir函数的作用是设置目录流的目录项指针。 12345#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;long int telldir(DIR *dirp);void seekdir(DIR *dirp, long int inc); closedir函数closedir函数关闭一个目录流并释放资源。在执行成功时返回0，发生错误时返回-1。 1234#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;int closedir(DIR *dirp); 下面是一个目录扫描程序 错误处理错误代码的取值和含义都在头文件error.h里。有两个非常有用的函数可以用来报告出现的错误。 strerror函数strerror函数把错误代码映射成一个字符串，该字符串对发生的错误类型进行说明。 123#include &lt;string.h&gt;char *strerror(int errnum); perror函数perror函数把errno变量中报告的错误映射到一个字符串，并输出到stderr中。该字符串前加上s中给出的信息，再加上一个冒号和一个空格。 123#include &lt;stdio.h&gt;void perror(const char *s); /proc文件系统Linux提供了一个特殊的文件系统procfs，它通常以/proc目录的形式呈现。该目录中包含了许多特殊文件用来对驱动程序和内核信息进行更高层的访问。 /proc/cpuinfo给出cpu的详细信息 /proc/meminfor给出内存使用情况 /proc/version给出内核版本情况 /proc/net/sockstat给出网络套接字的使用情况 /proc/sys/fs/file-max给出运行的程序同时能打开的文件总数。可以对其进行修改","link":"/2021/01/28/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"title":"Effective Modern C++ 读书笔记1","text":"理解模板中的类型推断对于一个函数模板 12template&lt;typename T&gt;void f(ParamType param); 可以这样调用这个函数模板： 1f(expr); 在编译时，编译器会使用expr对于两种类型：T和ParamType。这种在模板中进行的类型推断一般分为三种情况： 类型1：ParamType是引用或者指针，但不是Universal Reference首先假设ParamType是一种引用类型，在这种情况下类型推断按照下面的方式工作： 如果expr的类型是引用，忽略引用部分 对于expr的类型和ParamType进行模式匹配(pattern-match)来决定T 12345678910template&lt;typename T&gt;void f(T&amp; param);int x = 27;const int cx = x;const int&amp; rx = x;f(x); // T is int, param's type is int&amp;f(cx); // T is const int, param's type is const int&amp;f(rx); // T is const int, param's type is const int&amp; 如果param是一个指针，推断方式相似 类型2：ParamType是Universal Reference在这种情况下类型推断按照下面的方式工作： 如果expr是左值，T和ParamType都被推断为左值引用。 如果expr是右值，“常规”（类型1）法则适用 1234567891011template&lt;typename T&gt;void f(T&amp;&amp; param);int x = 27;const int cx = x;const int&amp; rx = x;f(x); // T is int&amp;, param's type is int&amp;f(cx); // T is const int&amp;, param's type is const int&amp;f(rx); // T is const int&amp;, param's type is const int&amp;f(27); // T is int, param's type is int&amp;&amp; 类型3：ParamType既不是指针也不是引用在这种情况下类型推断按照下面的方式工作： 如果expr的类型是引用，忽略引用部分 忽略expr的const和volatile等修饰词 12345678910111213template&lt;typename T&gt;void f(T param);int x = 27;const int cx = x;const int&amp; rx = x;const char* const ptr = &quot;sss&quot;;f(x); // T is intf(cx); // T is intf(rx); // T is intf(ptr); // T is const char * 使用数组或者函数名作为expr对于一般的函数，下面两种声明方式等价 12void myFunc(int param[]);void myFunc(int* param); 对于函数模板，情况如下： 1234567891011const char name[] = &quot;J. P. Briggs&quot;;template&lt;typename T&gt;void f(T param);f(name); // T is const char *template&lt;typename T&gt;void f1(T&amp; param);f1(name); // T is const char [13], param's type is const char (&amp;)[13] 可以利用模板推断实现下面的函数，返回数组长度 1234template&lt;typename T, std::size_t N&gt;constexpr std::size_N arraySize(T (&amp;)[N]) noexcept{ return N;} 对于函数名作为expr的情况 12345678910void func(int, double);template&lt;typename T&gt;void f1(T param);template&lt;typename T&gt;void f2(T param);f1(func); // param's type is void (*)(int, double)f2(func); // param's type is void (&amp;)(int, double) 理解auto的类型推断auto的类型推断和模板的类型推断几乎完全相同，下面是一些例子 12345678auto x = 27; // 类型3const auto cx = x; // 类型3const auto&amp; rx = x; // 类型1// 类型2auto&amp;&amp; uref1 = x; // uref1's type is int&amp;auto&amp;&amp; uref2 = cx; // uref2's type is const int&amp;auto&amp;&amp; uref3 = 27; // uref2's type is int&amp;&amp; 同样对于数组和函数名的推断也一样。 auto和模板的类型推断只有一个地方不同。在C++98中，给出了两种变量初始化的方法 12int x1 = 27;int x2(27); C++11中支持了统一初始化(uniform initialization) 12int x3 = { 27 };int x4{ 27 }; 我们可以将int替换为auto 1234auto x1 = 27; // type is intauto x2(27); // dittoauto x3 = { 27 }; // type is std::initializer_list&lt;int&gt;, value is { 27 }auto x4{ 27 }; // ditto 如果初始化auto-declared变量时使用花括号进行初始化，此时类型推断的结果就是std::initializer_list。如果推断失败（花括号中有多种类型），就会报错。 需要注意到这里的auto实际上进行了两次推断过程——一次推断出std::initializer_list&lt;T&gt;，一次推断出T为int。 而模板推断只能进行一次推断过程 123456789template&lt;typename T&gt;void f(T param);f({ 11, 23, 9 }); // errortemplate&lt;typename T&gt;void f1(std::initializer_list&lt;T&gt; initList);f1({ 11, 23, 9 }); // T is int, param's type is std::initializer_list&lt;int&gt; 对于C++14，虽然引入了auto作为返回值和auto作为lambda表达式参数，但是本质上和模板推断一致 12345678910// for C++14auto createInitList(){ return { 1, 2, 3 }; // error}std::vector&lt;int&gt; v;auto resetV = [&amp;v](const auto&amp; newValue) { v = newValue; };resetV({ 1, 2, 3 }); // error","link":"/2021/03/20/Effective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/"}],"tags":[{"name":"shell programming","slug":"shell-programming","link":"/tags/shell-programming/"},{"name":"linux command line","slug":"linux-command-line","link":"/tags/linux-command-line/"},{"name":"linux programming","slug":"linux-programming","link":"/tags/linux-programming/"},{"name":"c++","slug":"c","link":"/tags/c/"}],"categories":[{"name":"programming language","slug":"programming-language","link":"/categories/programming-language/"},{"name":"linux command line","slug":"linux-command-line","link":"/categories/linux-command-line/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}