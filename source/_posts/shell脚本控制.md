---
title: shell脚本控制
date: 2021-01-18 18:33:33
tags: 
   - shell programming
   - linux command line
categories: 
   - linux command line
toc: true
---
## shell 脚本控制

### 处理信号

1. 常见信号。

   | 信号 | 值        | 描述                   |
   | ---- | --------- | ---------------------- |
   | 1    | `SIGHUP`  | 挂起进程               |
   | 2    | `SIGINT`  | 终止进程               |
   | 3    | `SIGQUIT` | 停止进程               |
   | 9    | `SIGKILL` | 无条件终止             |
   | 15   | `SIGTERM` | 尽可能终止             |
   | 17   | `SIGSTOP` | 无条件停止，但不是终止 |
   | 18   | `SIGTSTP` | 停止或暂停，但不是终止 |
   | 19   | `SIGCONT` | 继续运行停止的进程     |

<!--more-->

2. 生成信号。bash shell运行用键盘上的组合键生成两种基本的信号。

   1. 中断进程。`Ctrl+C`组合键生成`SIGINT`，并将这个信号发送给在当前shell中运行的所有进程。

   2. 暂停进程。`Ctrl+Z`组合键生成`SIGTSTP`，停止shell中运行的任何进程。

      ``` bash
      $ sleep 100
      ^Z
      [1]+  Stopped                 sleep 100
      $ 
      ```

      方括号中的数字是shell分配的作业号。如果shell会话中有已停止的作业，在退出shell时会提醒。

      ``` bash
      $ exit
      logout
      There are stopped jobs.
      $
      ```

      被停止的进程可以使用`ps`命令查看。如果仍然想要退出只需要在输入一次`exit`命令，也可以使用`kill`命令手动终止。

      ``` bash
      $ kill -9 141
      $
      [1]+  Killed                  sleep 100
      ```

3. 捕获信号。`trap`命令允许你来指定shell脚本监看并从shell中拦截的linux信号。如果脚本收到了`trap`命令中列出的信号，该信号不再由shell处理，而是交由本地处理。

   ``` bash
   trap commands signals
   ```

   列出想要执行的命令，以及一组由空格分开的待捕获的信号。可以用数值或者信号名来指定信号。下面是一个例子

   ``` bash
   trap "receive a Ctrl+C" SIGINT
   count=1
   while [ $count -le 10 ]
   do
   	echo "Loop #$count"
   	sleep 1
   	count=$[ $count + 1 ]
   done
   ```

   在上面的循环执行的过程中按`Ctrl+C`或显示`receive a Ctrl+C`。

4. 捕获脚本退出。要捕获shell脚本的退出，只要在`trap`命令后加上`EXIT`信号就可以。

5. 修改或移除捕获。

   1. 修改。只需要重新使用`trap`命令即可
   2. 移除。只需要在`trap`命令与希望恢复行为的信号列表之间加上`--`就可以了。也可以在`trap`命令后使用单破折号来恢复信号的默认行为。

### 后台运行脚本

1. 后台运行脚本。只需要在命令后加上`&`就可以了，注意这时脚本仍然会使用显示屏显示`STDOUT`和`STDERR`消息（重定向很重要）。
2. 运行多个后台脚本。对于每个后台运行的进程都会分配作业号和进程号，可以使用`ps`命令查看，每一个后台进程都和终端会话联系在一起，如果终端会话退出。那么后台进程也会退出。（如果使用了后台进程并且打算退出进程，只有某些终端仿真器会在退出时提醒）

### 在非控制台下运行脚本

可以使用`nohup`命令使得后台脚本能够在终端退出后继续运行。`nohup`命令的格式如下

``` bash
$ nohup test.sh &
```

和普通后台进程一样，shell会给命令分配一个作业号，linux系统会为其分配一个PID号。区别在于，使用`nohup`时，如果关闭该会话，脚本会忽略终端会话发来的`SIGHUP`信号。同时进程会把`STDOUT`和`STDERR`的输出自动重定向到名为nohup.out的文件中。

### 作业控制

1. 查看作业。`jobs`命令查看当前正在处理的作业。`jobs`命令会显示当前已停止/运行中的作业，以及作业号和命令。可以加上`-l`选项来显示作业的PID。`jobs`的输出如下

   ``` bash
   $ jobs -l
   [1]+  2333 Stopped  ./test.sh 
   [2]-  1314 Running  ./test.sh > test.out &
   ```

   输出中的`+`代表这个作业被当作默认作业。在使用作业控制命令时，如果未指定作业号，改作业就会被当作操作对象。当默认作业完成处理之后，`-`号的作业就成为下一个默认作业。任何时候都只有一个带`+`和一个带`-`的作业。

2. 重启停止的作业。

   1. 后台模式重启。使用`bg`命令加上作业号（注意是作业号）
   2. 前台模式重启。使用`fg`命令加上作业号

### 调整谦让度

linux中，由shell启动的所有进程的调度优先级默认都是相同的。调度优先级是一个整数值，从-20（最高优先级）到19（最低优先级）。默认情况下，bash shell以优先级0来启动所有进程。

1. `nice`命令。`nice`命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级允许，只要用`nice`命令的`-n`选项就可以了。

   ``` bash
   $ nice -n 10 ./test.sh > test.out &
   ```

   通过`ps`命令可以发现进程的`NI`值被设置为10。但是如果想要提高某个命令的优先级，会出现如下输出

   ``` bash
   $ nice -n -10 ./test.sh > test.out &
    [1] 2333
   $ nice: cannot set niceness: Permission denied
    [1]+ Done         nice -n -10 ./test.sh > test.out 
   $
   ```

   `nice`命令组织普通用户提高优先级，注意这里指定的命令执行了只是`nice`命令失败了。

2. `renice`命令。`renice`命令可以改变正在运行的程序的优先级，

   ``` bash
   $ renice -n NI -p PID
   ```

   通过`-n`选项指定优先级，`-p`选项指定PID即可。和`nice`命令一样`renice`也存在一些限制：

   1. 只能对于属于你的进程使用`renice`
   2. 只能通过`renice`命令降低优先级
   3. root用户可以随意调整

### 定时运行程序

#### 用`at`命令来计划执行作业

`at`命令会将作业提交到队列中，指定shell何时运行该作业。`at`的守护进程`atd`会以后台模式运行，检查作业队列来运行作业。`atd`守护进程会检查系统上的一个特殊目录（通常位于`/var/spool/at`）来获取用`at`命令提交的作业。默认情况下，`atd`守护进程会每60s检查一下这个目录。有作业时，`atd`守护进程会检查作业设置运行的时间。如果时间和当前时间匹配，`atd`守护检查就会运行此作业。

1. at命令的格式。

   ``` bash
   at [-f filename] time
   ```

   默认情况下，`at`命令读取`STDIN`的输入，可以使用`-f`选项指定脚本。`time`参数指定了何时运行该作业。如果时间已经错过，`at`命令会在第二天那个时间运行指定的作业。`at`命令可以识别多种时间的格式

   1. 标准的小时分钟格式。如10:10
   2. AM/PM格式。如10:10 PM
   3. 特殊的可命名时间。如now、noon、midnight。

   也可以用不同的日期格式指定特定的日期

   1. 标准日期格式。如MMDDYY、MM/DD/YY或DD.MM.YY。
   2. 文本日期。如Dec 25。
   3. 也可以使用时间增量。如当前时间+25min，明天10:15 PM，10:15+7天。

   在你使用`at`命令时，作业会被提交到作业队列中，针对不同的优先级，存在26种不同的作业队列，作业队列通常用小写字母a~z和大写字母A~Z来指代。字母排序越高，作业运行的优先级就越低。默认情况下提交到a队列，可以使用`-q`选项指定队列。

2. 获取作业的输出。此时输出会以e-mail的形式发送，建议在脚本中加入重定向，如果输出不重要，可以使用`at`的`-M`选项来屏蔽作业的输出信息。

3. 列出、删除等待的作业。

   1. `atq`命令可以查看当前正在等待的作业。
   2. `atrm`命令通过指定作业号来删除在队列中等待的作业。

#### 安排定期执行的脚本

linux使用`cron`程序来安排要定期执行的作业。

1. `cron`时间表。`cron`时间表采用一种特殊的格式来指定作业何时运行。格式如下：

   ``` bash
   min hour dayofmonth month dayofweek command
   ```

   `cron`时间表允许你用特定值、取值范围（比如1-5）或者时通配符（`*`）来指定条目。下面是几个例子

   ``` bash
   #在凌晨00:01运行
   1 0 * * * /home/yiming/test.sh
   
   #每个工作日23:59都进行备份作业
   23 59 * * 1-5 /home/yiming/test.sh
   23 59 * * 1,2,3,4,5 /home/yiming/test.sh
   
   #每分钟运行一次命令
   */1 * * * * /home/yiming/test.sh
   
   #每个月的1号14:10运行
   10 14 1 * * /home/yiming/test.sh
   
   #每个月最后一天的00:01运行
   1 0 * * * [[ "$(date +%d -d tomorrow)" == "01" ]] && /home/yiming/test.sh
   ```

   命令列表必须指定要运行提交的命令或脚本的全路径名。`cron`会用提交作业的账号运行该脚本。

2. 创建`cron`时间表。使用`-l`选项列出当前用户已有的时间表。使用`-e`选项添加`cron`时间表。

3. 浏览`cron`目录。如果对于脚本运行的时间精度要求不高，使用预配置的`cron`脚本目录更方便，有四个`/etc/cron.hourly/  /etc/cron.dayly/   /etc/cron.weekly/  /etc/cron.monthly/`，直接把脚本复制到对应文件夹下即可。

4. `anacron`程序。`cron`程序默认linux一直开机，如果出现了关机后开机错过时间的情况不会重新执行。这个问题可以使用`anacron`程序解决，`anacron`程序只会处理位于`cron`目录下的程序，例如`/etc/cron.monthly`（不会处理`/ect/cron.hourly`下的程序）。他用时间戳来决定作业是否正常运行了。时间戳位于`/var/spool/anacron`。

#### 使用新shell启动脚本

可以将每次打开shell时需要运行的shell脚本放在`$HOME/.bashrc`文件中。

